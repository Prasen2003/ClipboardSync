[
  "8500g",
  "package com.example.clipboardsync\r\n\r\nimport android.content.*\r\nimport android.net.nsd.*\r\nimport android.os.*\r\nimport android.provider.Settings\r\nimport android.widget.Toast\r\nimport androidx.activity.ComponentActivity\r\nimport androidx.activity.compose.setContent\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.unit.sp\r\nimport okhttp3.*\r\nimport org.json.JSONArray\r\nimport org.json.JSONObject\r\nimport java.io.IOException\r\nimport androidx.compose.foundation.clickable\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.verticalScroll\r\nimport android.content.ClipData\r\nimport android.content.Context\r\nimport android.content.SharedPreferences\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.lazy.items\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport kotlinx.coroutines.*\r\nimport okhttp3.OkHttpClient\r\nimport okhttp3.Request\r\nimport java.util.concurrent.TimeUnit\r\nimport androidx.activity.compose.rememberLauncherForActivityResult\r\nimport androidx.activity.result.contract.ActivityResultContracts\r\nimport android.net.Uri\r\nimport android.os.Handler\r\nimport android.os.Looper\r\nimport java.io.File\r\nimport okhttp3.MediaType.Companion.toMediaTypeOrNull\r\nimport okhttp3.RequestBody.Companion.asRequestBody\r\nimport android.webkit.MimeTypeMap\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material3.ButtonDefaults\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.foundation.*\r\nimport androidx.compose.material3.TextFieldDefaults\r\nimport kotlinx.coroutines.delay\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Visibility\r\nimport androidx.compose.material.icons.filled.VisibilityOff\r\nimport androidx.compose.ui.text.input.PasswordVisualTransformation\r\nimport androidx.compose.ui.text.input.VisualTransformation\r\nimport android.content.ContentValues\r\nimport android.os.Build\r\nimport android.provider.MediaStore\r\nimport java.io.InputStream\r\nimport java.net.URLConnection\r\nimport android.os.Environment\r\nimport javax.crypto.Cipher\r\nimport javax.crypto.spec.SecretKeySpec\r\nimport java.security.MessageDigest\r\nimport android.util.Base64\r\nimport java.security.SecureRandom\r\nimport javax.crypto.SecretKeyFactory\r\nimport javax.crypto.spec.IvParameterSpec\r\nimport javax.crypto.spec.PBEKeySpec\r\nimport javax.crypto.CipherInputStream\r\nimport android.util.Base64InputStream\r\nimport androidx.core.app.NotificationCompat\r\nimport androidx.core.app.NotificationManagerCompat\r\nimport android.app.PendingIntent\r\nimport android.content.Intent\r\nimport androidx.core.content.FileProvider\r\nimport android.content.pm.PackageManager\r\nimport androidx.core.app.ActivityCompat\r\nimport android.app.NotificationChannel\r\nimport android.app.NotificationManager\r\n\r\n@Composable\r\nfun ClipboardSyncApp() {\r\n    val context = LocalContext.current\r\n    val clipboardManager = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n    val prefs = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n    var downloadingCount by remember { mutableStateOf(0) }\r\n    val isDownloading = downloadingCount > 0\r\n    var uploadingCount by remember { mutableStateOf(0) }\r\n    val isUploading = uploadingCount > 0\r\n    var showFileDialog by remember { mutableStateOf(false) }\r\n    var lastText by remember { mutableStateOf(\"\") }\r\n    var ipAddress by remember { mutableStateOf(prefs.getString(\"server_ip\", \"\") ?: \"\") }\r\n    var history by remember { mutableStateOf(loadHistory(prefs)) }\r\n    var isConnected by remember { mutableStateOf(false) }\r\n    var password by remember { mutableStateOf(prefs.getString(\"server_password\", \"\") ?: \"\") }\r\n    var availableFiles by remember { mutableStateOf<List<String>>(emptyList()) }\r\n    val ip = prefs.getString(\"server_ip\", \"\") ?: \"\"\r\n    var clipboardHistory by remember { mutableStateOf(listOf<String>()) }\r\n    val fileLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\r\n        uri?.let {\r\n            uploadFileToServer(context, it, ipAddress, password) { uploading ->\r\n                uploadingCount = when {\r\n                    uploading -> uploadingCount + 1\r\n                    uploadingCount > 0 -> uploadingCount - 1\r\n                    else -> 0\r\n                }\r\n            }\r\n        }\r\n    }\r\n    val buttonColor = Color(0xFF546E7A)\r\n    val buttonTextColor = Color.White\r\n\r\n    fun savePassword(pass: String) = prefs.edit().putString(\"server_password\", pass).apply()\r\n    fun saveIp(ip: String) = prefs.edit().putString(\"server_ip\", ip).apply()\r\n\r\n    fun addToHistory(text: String) {\r\n        val newHistory = listOf(text) + history.filterNot { it == text }\r\n        history = newHistory.take(50)\r\n        prefs.edit().putString(\"clipboard_history\", JSONArray(newHistory).toString()).apply()\r\n    }\r\n\r\n    fun deleteFromHistory(item: String) {\r\n        history = history.filterNot { it == item }\r\n        prefs.edit().putString(\"clipboard_history\", JSONArray(history).toString()).apply()\r\n    }\r\n\r\n    LaunchedEffect(ipAddress) {\r\n        while (true) {\r\n            pingServer(context, ipAddress, password) { isConnected = it }\r\n            delay(5000)\r\n        }\r\n    }\r\n\r\n    LaunchedEffect(Unit) {\r\n        discoverService(context) {\r\n            ipAddress = it\r\n            saveIp(it)\r\n        }\r\n        clipboardManager.primaryClip?.getItemAt(0)?.text?.toString()?.let {\r\n            if (it.isNotBlank()) {\r\n                lastText = it\r\n                addToHistory(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    DisposableEffect(Unit) {\r\n        val listener = ClipboardManager.OnPrimaryClipChangedListener {\r\n            val text = clipboardManager.primaryClip?.getItemAt(0)?.text.toString()\r\n            if (text.isNotBlank() && text != lastText) {\r\n                lastText = text\r\n                addToHistory(text)\r\n                sendToServer(context, text, ipAddress, password)\r\n            }\r\n        }\r\n        clipboardManager.addPrimaryClipChangedListener(listener)\r\n        onDispose { clipboardManager.removePrimaryClipChangedListener(listener) }\r\n    }\r\n\r\n    var selectedItem by remember { mutableStateOf<String?>(null) }\r\n    var passwordVisible by remember { mutableStateOf(false) }\r\n\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .background(Color(0xFF263238)) // dark blue-grey\r\n            .padding(16.dp),\r\n        verticalArrangement = Arrangement.spacedBy(16.dp)\r\n    ) {Card(\r\n        modifier = Modifier.fillMaxWidth(),\r\n        colors = CardDefaults.cardColors(containerColor = Color(0xFF37474F)),\r\n        shape = RoundedCornerShape(8.dp),\r\n        elevation = CardDefaults.cardElevation(4.dp)\r\n    ) {\r\n        Column(modifier = Modifier.padding(16.dp)) {\r\n\r\n            Row(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                horizontalArrangement = Arrangement.SpaceBetween,\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                Text(\r\n                    text = \"Connection Settings\",\r\n                    fontSize = 18.sp,\r\n                    color = Color.White\r\n                )\r\n\r\n                Text(\r\n                    text = if (isConnected) \"🟢 Connected\" else \"🔴 Disconnected\",\r\n                    color = if (isConnected) Color.Green else Color.Red,\r\n                    fontSize = 14.sp\r\n                )\r\n            }\r\n\r\n            Spacer(modifier = Modifier.height(12.dp))\r\n\r\n            Row(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                horizontalArrangement = Arrangement.spacedBy(8.dp),\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                TextField(\r\n                    value = ipAddress,\r\n                    onValueChange = {\r\n                        ipAddress = it\r\n                        saveIp(it)\r\n                    },\r\n                    label = { Text(\"Server IP Address\", color = Color.White) },\r\n                    singleLine = true,\r\n                    modifier = Modifier.weight(1f),\r\n                    colors = TextFieldDefaults.colors(\r\n                        focusedTextColor = Color.White,\r\n                        unfocusedTextColor = Color.White,\r\n                        focusedContainerColor = Color(0xFF455A64),\r\n                        unfocusedContainerColor = Color(0xFF455A64),\r\n                        focusedLabelColor = Color.White,\r\n                        unfocusedLabelColor = Color.White,\r\n                        focusedIndicatorColor = Color.White,\r\n                        unfocusedIndicatorColor = Color.White,\r\n                        cursorColor = Color.White\r\n                    )\r\n                )\r\n\r\n                Button(\r\n                    onClick = {\r\n                        discoverService(context) {\r\n                            ipAddress = it\r\n                            saveIp(it)\r\n                            Toast.makeText(context, \"🔄 IP updated to $it\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    },\r\n                    modifier = Modifier\r\n                        .height(56.dp)\r\n                        .width(56.dp),\r\n                    shape = RoundedCornerShape(8.dp),\r\n                    colors = ButtonDefaults.buttonColors(\r\n                        containerColor = buttonColor,\r\n                        contentColor = buttonTextColor\r\n                    ),\r\n                    contentPadding = PaddingValues(0.dp)\r\n                ) {\r\n                    Text(\"🔄\", fontSize = 22.sp)\r\n                }\r\n            }\r\n\r\n            Spacer(modifier = Modifier.height(8.dp))\r\n\r\n            TextField(\r\n                value = password,\r\n                onValueChange = {\r\n                    password = it\r\n                    savePassword(it)\r\n                },\r\n                label = { Text(\"Server Password\", color = Color.White) },\r\n                singleLine = true,\r\n                modifier = Modifier.fillMaxWidth(),\r\n                visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),\r\n                trailingIcon = {\r\n                    IconButton(onClick = { passwordVisible = !passwordVisible }) {\r\n                        Icon(\r\n                            imageVector = if (passwordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility,\r\n                            contentDescription = if (passwordVisible) \"Hide password\" else \"Show password\",\r\n                            tint = Color.White\r\n                        )\r\n                    }\r\n                },\r\n                colors = TextFieldDefaults.colors(\r\n                    focusedTextColor = Color.White,\r\n                    unfocusedTextColor = Color.White,\r\n                    focusedContainerColor = Color(0xFF455A64),\r\n                    unfocusedContainerColor = Color(0xFF455A64),\r\n                    focusedLabelColor = Color.White,\r\n                    unfocusedLabelColor = Color.White,\r\n                    focusedIndicatorColor = Color.White,\r\n                    unfocusedIndicatorColor = Color.White,\r\n                    cursorColor = Color.White\r\n                )\r\n            )\r\n        }\r\n    }\r\n        Divider(color = Color.Gray)\r\n\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(12.dp)\r\n        ) {\r\n            Button(\r\n                onClick = {\r\n                    clipboardManager.primaryClip?.getItemAt(0)?.text?.toString()?.let { text ->\r\n                        lastText = text\r\n                        addToHistory(text)\r\n                        sendToServer(context, text, ipAddress, password)\r\n                    }\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"\\uD83D\\uDCE4 Sync Text\")\r\n            }\r\n\r\n            Button(\r\n                onClick = {\r\n                    fetchClipboardFromServer(\r\n                        context = context,\r\n                        ip = ip,\r\n                        password = password,\r\n                        clipboardManager = clipboardManager,\r\n                        addToHistory = { text -> addToHistory(text) },\r\n                        onComplete = { /* handle UI update after fetch */ }\r\n                    )\r\n\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"\\uD83D\\uDCE5 Fetch Text\")\r\n            }\r\n        }\r\n\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(8.dp)\r\n        ) {\r\n            Button(\r\n                onClick = { fileLauncher.launch(\"*/*\") },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"📁 Send File\")\r\n            }\r\n\r\n            Button(\r\n                onClick = {\r\n                    downloadingCount += 1\r\n                    fetchClipboardFromServer(\r\n                        context = context,\r\n                        ip = ipAddress,\r\n                        password = password,\r\n                        clipboardManager = clipboardManager,\r\n                        addToHistory = { text -> clipboardHistory = clipboardHistory + text },\r\n                        onComplete = { downloadingCount = maxOf(downloadingCount - 1, 0) }\r\n                    )\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"📃 Fetch File\")\r\n            }\r\n\r\n\r\n        }\r\n        if (showFileDialog) {\r\n            AlertDialog(\r\n                onDismissRequest = { showFileDialog = false },\r\n                title = { Text(\"Available Files\", color = Color.White) },\r\n                text = {\r\n                    Column(\r\n                        modifier = Modifier\r\n                            .heightIn(min = 100.dp, max = 400.dp)\r\n                            .verticalScroll(rememberScrollState())\r\n                    ) {\r\n                        if (availableFiles.isEmpty()) {\r\n                            Text(\"No files found\", color = Color.White)\r\n                        } else {\r\n                            availableFiles.forEach { file ->\r\n                                Row(\r\n                                    modifier = Modifier\r\n                                        .fillMaxWidth()\r\n                                        .clickable {\r\n                                            downloadingCount += 1\r\n                                            downloadFileFromServer(context, file, ipAddress, password) {\r\n                                                downloadingCount = maxOf(downloadingCount - 1, 0)\r\n                                            }\r\n                                            showFileDialog = false\r\n                                        }\r\n                                        .padding(vertical = 8.dp),\r\n                                    verticalAlignment = Alignment.CenterVertically\r\n                                ) {\r\n                                    Text(file, color = Color.White, modifier = Modifier.weight(1f))\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                confirmButton = {\r\n                    TextButton(onClick = { showFileDialog = false }) {\r\n                        Text(\"Close\", color = Color.White)\r\n                    }\r\n                },\r\n                containerColor = Color(0xFF37474F)\r\n            )\r\n        }\r\n\r\n        if (isUploading) {\r\n            Spacer(modifier = Modifier.height(8.dp))\r\n            Text(\"Uploading...\", fontSize = 14.sp, color = Color.White)\r\n        }\r\n        if (isDownloading) {\r\n            Spacer(modifier = Modifier.height(4.dp))\r\n            Text(\"Downloading...\", fontSize = 14.sp, color = Color.White)\r\n        }\r\n\r\n        Divider(color = Color.Gray)\r\n        Text(\"Clipboard History\", fontSize = 18.sp, color = Color.White)\r\n\r\n        LazyColumn(\r\n            modifier = Modifier\r\n                .fillMaxSize()\r\n                .padding(top = 2.dp)\r\n        ) {\r\n\r\n            items(history) { item ->\r\n                Row(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .padding(vertical = 6.dp)\r\n                        .clickable { selectedItem = item },\r\n                    horizontalArrangement = Arrangement.SpaceBetween,\r\n                    verticalAlignment = Alignment.CenterVertically\r\n                ) {\r\n                    Text(\r\n                        item.take(50).replace(\"\\n\", \" \"),\r\n                        fontSize = 14.sp,\r\n                        color = Color.White,\r\n                        modifier = Modifier.weight(1f)\r\n                    )\r\n                    Row {\r\n                        IconButton(onClick = {\r\n                            val clip = ClipData.newPlainText(\"Copied\", item)\r\n                            clipboardManager.setPrimaryClip(clip)\r\n                            Toast.makeText(context, \"📋 Copied to clipboard\", Toast.LENGTH_SHORT)\r\n                                .show()\r\n                        }) {\r\n                            Text(\"📋\", color = Color.White)\r\n                        }\r\n                        IconButton(onClick = { deleteFromHistory(item) }) {\r\n                            Text(\"🗑️\", color = Color.White)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n        // Expanded History View Dialog\r\n    selectedItem?.let {\r\n        val scrollState = rememberScrollState()\r\n        AlertDialog(\r\n            onDismissRequest = { selectedItem = null },\r\n            title = { Text(\"Clipboard Entry\", color = Color.White) },\r\n            text = {\r\n                Column(\r\n                    modifier = Modifier\r\n                        .heightIn(min = 100.dp, max = 400.dp)\r\n                        .verticalScroll(scrollState)\r\n                        .padding(4.dp)\r\n                ) {\r\n                    Text(it, fontSize = 14.sp, color = Color.White)\r\n                }\r\n            },\r\n            confirmButton = {\r\n                TextButton(onClick = { selectedItem = null }) {\r\n                    Text(\"Close\", color = Color.White)\r\n                }\r\n            },\r\n            containerColor = Color(0xFF37474F)\r\n        )\r\n    }\r\n}\r\n// --- CONFIG --- //\r\nprivate const val PBKDF2_ITERATIONS = 10000\r\nprivate const val KEY_LENGTH = 256 // bits\r\nprivate const val SALT_SIZE = 16   // bytes\r\nprivate const val IV_SIZE = 16     // bytes\r\n\r\n// --- KEY DERIVATION --- //\r\nprivate fun deriveKey(password: String, salt: ByteArray): SecretKeySpec {\r\n    val factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\")\r\n    val spec = PBEKeySpec(password.toCharArray(), salt, PBKDF2_ITERATIONS, KEY_LENGTH)\r\n    val tmp = factory.generateSecret(spec)\r\n    return SecretKeySpec(tmp.encoded, \"AES\")\r\n}\r\n\r\n// --- RANDOM GENERATORS --- //\r\nprivate fun randomBytes(size: Int): ByteArray {\r\n    val bytes = ByteArray(size)\r\n    SecureRandom().nextBytes(bytes)\r\n    return bytes\r\n}\r\n\r\n// --- SECURE ENCRYPTION FOR TEXT --- //\r\nfun encryptAESCBC(text: String, password: String): String {\r\n    val salt = randomBytes(SALT_SIZE)\r\n    val iv = randomBytes(IV_SIZE)\r\n    val key = deriveKey(password, salt)\r\n\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\r\n    val encrypted = cipher.doFinal(text.toByteArray(Charsets.UTF_8))\r\n    // Output: salt + iv + ciphertext (all base64 encoded)\r\n    val out = ByteArray(salt.size + iv.size + encrypted.size)\r\n    System.arraycopy(salt, 0, out, 0, salt.size)\r\n    System.arraycopy(iv, 0, out, salt.size, iv.size)\r\n    System.arraycopy(encrypted, 0, out, salt.size + iv.size, encrypted.size)\r\n    return Base64.encodeToString(out, Base64.NO_WRAP)\r\n}\r\n\r\nfun decryptAESCBC(encrypted: String, password: String): String {\r\n    val decoded = Base64.decode(encrypted, Base64.NO_WRAP)\r\n    val salt = decoded.copyOfRange(0, SALT_SIZE)\r\n    val iv = decoded.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n    val ciphertext = decoded.copyOfRange(SALT_SIZE + IV_SIZE, decoded.size)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n    val decrypted = cipher.doFinal(ciphertext)\r\n    return String(decrypted, Charsets.UTF_8)\r\n}\r\n\r\n// --- SECURE ENCRYPTION FOR FILES (BYTES) --- //\r\nfun encryptFileBytesCBC(data: ByteArray, password: String): ByteArray {\r\n    val salt = randomBytes(SALT_SIZE)\r\n    val iv = randomBytes(IV_SIZE)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\r\n    val encrypted = cipher.doFinal(data)\r\n    // Output: salt + iv + ciphertext\r\n    val out = ByteArray(salt.size + iv.size + encrypted.size)\r\n    System.arraycopy(salt, 0, out, 0, salt.size)\r\n    System.arraycopy(iv, 0, out, salt.size, iv.size)\r\n    System.arraycopy(encrypted, 0, out, salt.size + iv.size, encrypted.size)\r\n    return out\r\n}\r\n\r\nfun decryptFileBytesCBC(data: ByteArray, password: String): ByteArray {\r\n    val salt = data.copyOfRange(0, SALT_SIZE)\r\n    val iv = data.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n    val ciphertext = data.copyOfRange(SALT_SIZE + IV_SIZE, data.size)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n    return cipher.doFinal(ciphertext)\r\n}\r\n\r\nfun showDownloadNotification(context: Context, filePathOrUri: String, filename: String, mimeType: String) {\r\n    val channelId = \"clipboard_download_channel\"\r\n    val notificationId = 1001\r\n\r\n    // Channel creation should NOT depend on permission!\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        val name = \"ClipboardSync Downloads\"\r\n        val descriptionText = \"Notifications for completed file downloads\"\r\n        val importance = NotificationManager.IMPORTANCE_DEFAULT\r\n        val channel = NotificationChannel(channelId, name, importance).apply {\r\n            description = descriptionText\r\n        }\r\n        val notificationManager: NotificationManager =\r\n            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n        notificationManager.createNotificationChannel(channel)\r\n    }\r\n\r\n    // Check notification permission for Android 13+ (API 33+)\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU &&\r\n        ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS)\r\n        != PackageManager.PERMISSION_GRANTED) {\r\n        // Permission not granted, just return (don't crash)\r\n        return\r\n    }\r\n\r\n    // Prepare an intent to open the file\r\n    val fileUri: Uri = if (filePathOrUri.startsWith(\"content://\")) {\r\n        Uri.parse(filePathOrUri)\r\n    } else {\r\n        File(filePathOrUri).let { file ->\r\n            FileProvider.getUriForFile(context, context.packageName + \".provider\", file)\r\n        }\r\n    }\r\n\r\n    val openIntent = Intent(Intent.ACTION_VIEW).apply {\r\n        setDataAndType(fileUri, mimeType)\r\n        addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK)\r\n    }\r\n    val pendingIntent = PendingIntent.getActivity(\r\n        context, 0, openIntent,\r\n        PendingIntent.FLAG_UPDATE_CURRENT or\r\n                (if (Build.VERSION.SDK_INT >= 31) PendingIntent.FLAG_MUTABLE else 0)\r\n    )\r\n\r\n    val notification = NotificationCompat.Builder(context, channelId)\r\n        .setSmallIcon(android.R.drawable.stat_sys_download_done)\r\n        .setContentTitle(\"Download complete\")\r\n        .setContentText(filename)\r\n        .setPriority(NotificationCompat.PRIORITY_DEFAULT)\r\n        .setAutoCancel(true)\r\n        .addAction(android.R.drawable.ic_menu_view, \"Open\", pendingIntent)\r\n        .build()\r\n\r\n    NotificationManagerCompat.from(context).notify(notificationId, notification)\r\n}\r\n\r\nfun pingServer(context: Context, ip: String, password: String, onResult: (Boolean) -> Unit) {\r\n    if (ip.isBlank()) {\r\n        onResult(false)\r\n        return\r\n    }\r\n\r\n    CoroutineScope(Dispatchers.IO).launch {\r\n        try {\r\n            val client = OkHttpClient.Builder()\r\n                .callTimeout(2, TimeUnit.SECONDS)\r\n                .build()\r\n\r\n            val request = Request.Builder()\r\n                .url(\"http://$ip:8000/ping\")\r\n                .get()\r\n                .addHeader(\"X-Auth-Token\", password)\r\n                .build()\r\n\r\n            val response = client.newCall(request).execute()\r\n            onResult(response.isSuccessful)\r\n        } catch (e: Exception) {\r\n            onResult(false)\r\n        }\r\n    }\r\n}\r\n\r\nfun loadHistory(prefs: SharedPreferences): List<String> {\r\n    val json = prefs.getString(\"clipboard_history\", \"[]\")\r\n    return try {\r\n        val arr = JSONArray(json)\r\n        List(arr.length()) { i -> arr.getString(i) }\r\n    } catch (e: Exception) {\r\n        emptyList()\r\n    }\r\n}\r\n\r\nfun discoverService(context: Context, onFound: (String) -> Unit) {\r\n    val nsdManager = context.getSystemService(Context.NSD_SERVICE) as NsdManager\r\n    val serviceType = \"_http._tcp.\"\r\n    val serviceNamePrefix = \"ClipboardSyncServer\"\r\n    lateinit var discoveryListener: NsdManager.DiscoveryListener\r\n\r\n    discoveryListener = object : NsdManager.DiscoveryListener {\r\n        override fun onDiscoveryStarted(serviceType: String) {}\r\n        override fun onStopDiscoveryFailed(serviceType: String?, errorCode: Int) {}\r\n        override fun onStartDiscoveryFailed(serviceType: String?, errorCode: Int) {}\r\n        override fun onDiscoveryStopped(serviceType: String) {}\r\n        override fun onServiceFound(serviceInfo: NsdServiceInfo) {\r\n            if (serviceInfo.serviceName.contains(serviceNamePrefix)) {\r\n                nsdManager.resolveService(serviceInfo, object : NsdManager.ResolveListener {\r\n                    override fun onResolveFailed(serviceInfo: NsdServiceInfo?, errorCode: Int) {}\r\n                    override fun onServiceResolved(resolved: NsdServiceInfo) {\r\n                        val host = resolved.host.hostAddress\r\n                        if (host != null) {\r\n                            onFound(host)\r\n                            nsdManager.stopServiceDiscovery(discoveryListener)\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        override fun onServiceLost(serviceInfo: NsdServiceInfo) {}\r\n    }\r\n\r\n    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener)\r\n}\r\n\r\nfun uploadFileToServer(context: Context,\r\n                       uri: Uri,\r\n                       ip: String,\r\n                       password: String,\r\n                       onUploadingChanged: (Boolean) -> Unit) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"❗ No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        return\r\n    }\r\n    onUploadingChanged(true)\r\n    val contentResolver = context.contentResolver\r\n\r\n    // Step 1: Get MIME type and map to extension\r\n    val mimeType = contentResolver.getType(uri)\r\n    val extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType) ?: \"bin\"\r\n\r\n    // Step 2: Try to get the original filename or fallback\r\n    var fileName = uri.lastPathSegment?.substringAfterLast('/') ?: \"upload\"\r\n\r\n    // Step 3: Ensure filename has correct extension\r\n    if (!fileName.contains('.')) {\r\n        fileName += \".$extension\"\r\n    }\r\n\r\n    val inputStream = contentResolver.openInputStream(uri) ?: return\r\n    val tempFile = File.createTempFile(\"upload\", null, context.cacheDir)\r\n    inputStream.use { input -> tempFile.outputStream().use { output -> input.copyTo(output) } }\r\n\r\n    val fileBytes = tempFile.readBytes()\r\n    val encryptedBytes = encryptFileBytesCBC(fileBytes, password)\r\n    tempFile.writeBytes(encryptedBytes)\r\n\r\n    val fileBody = tempFile.asRequestBody(\"application/octet-stream\".toMediaTypeOrNull())\r\n\r\n    val multipartBody = MultipartBody.Builder()\r\n        .setType(MultipartBody.FORM)\r\n        .addFormDataPart(\"file\", fileName, fileBody)\r\n        .build()\r\n\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/upload\")\r\n        .post(multipartBody)\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    val client = OkHttpClient()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"❌ Upload failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onUploadingChanged(false) // Upload ended with failure\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                if (response.isSuccessful) {\r\n                    Toast.makeText(context, \"✅ File uploaded successfully\", Toast.LENGTH_SHORT).show()\r\n                } else {\r\n                    Toast.makeText(context, \"⚠️ Upload failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n                onUploadingChanged(false) // Upload ended (success or failure)\r\n            }\r\n        }\r\n    })\r\n}\r\nfun fetchFileListFromServer(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    onResult: (List<String>) -> Unit\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"❗ No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onResult(emptyList())\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/list-files\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"❌ Failed to get file list\", Toast.LENGTH_SHORT).show()\r\n                onResult(emptyList())\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"⚠️ Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onResult(emptyList())\r\n                }\r\n                return\r\n            }\r\n\r\n            val body = response.body?.string()\r\n            val fileList = try {\r\n                val json = JSONObject(body ?: \"{}\")\r\n                val filesArray = json.getJSONArray(\"files\")\r\n                List(filesArray.length()) { i -> filesArray.getString(i) }\r\n            } catch (e: Exception) {\r\n                emptyList()\r\n            }\r\n\r\n            Handler(Looper.getMainLooper()).post {\r\n                onResult(fileList)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun saveFileToDownloads(\r\n    context: Context,\r\n    filename: String,\r\n    mimeType: String,\r\n    inputStream: InputStream,\r\n    size: Long\r\n): String? {\r\n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n        // API 29+\r\n        val values = ContentValues().apply {\r\n            put(MediaStore.Downloads.DISPLAY_NAME, filename)\r\n            put(MediaStore.Downloads.MIME_TYPE, mimeType)\r\n            put(MediaStore.Downloads.IS_PENDING, 1)\r\n        }\r\n\r\n        val resolver = context.contentResolver\r\n        val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n        val fileUri = resolver.insert(collection, values)\r\n\r\n        if (fileUri != null) {\r\n            resolver.openOutputStream(fileUri)?.use { output ->\r\n                inputStream.copyTo(output)\r\n            }\r\n            values.clear()\r\n            values.put(MediaStore.Downloads.IS_PENDING, 0)\r\n            resolver.update(fileUri, values, null, null)\r\n            return fileUri.toString()\r\n        } else {\r\n            null\r\n        }\r\n    } else {\r\n        // Below API 29\r\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n        if (!downloadsDir.exists()) downloadsDir.mkdirs()\r\n        val file = File(downloadsDir, filename)\r\n        inputStream.use { input ->\r\n            file.outputStream().use { output ->\r\n                input.copyTo(output)\r\n            }\r\n        }\r\n        return file.absolutePath\r\n    }\r\n}\r\n\r\nfun downloadFileFromServer(\r\n    context: Context,\r\n    filename: String,\r\n    ip: String,\r\n    password: String,\r\n    onComplete: () -> Unit = {}\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"❗ No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onComplete()\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download/$filename\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"❌ Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful || response.body == null) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"⚠️ Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onComplete()\r\n                }\r\n                return\r\n            }\r\n            try {\r\n                val encryptedStream = response.body!!.byteStream()\r\n                // --- Patch: decode base64 on the fly ---\r\n                val b64Stream = Base64InputStream(encryptedStream, android.util.Base64.DEFAULT)\r\n\r\n                // Read salt + iv headers (first 32 bytes) from the decoded stream\r\n                val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n                var read = 0\r\n                while (read < header.size) {\r\n                    val r = b64Stream.read(header, read, header.size - read)\r\n                    if (r == -1) throw IOException(\"Unexpected EOF in header\")\r\n                    read += r\r\n                }\r\n                val salt = header.copyOfRange(0, SALT_SIZE)\r\n                val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n                val key = deriveKey(password, salt)\r\n                val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n                cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n                val decryptedStream = CipherInputStream(b64Stream, cipher)\r\n\r\n                val mimeType = URLConnection.guessContentTypeFromName(filename)\r\n                    ?: \"application/octet-stream\"\r\n\r\n                val savedPath = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    saveToDownloadsQAndAbove(context, filename, mimeType, decryptedStream, -1)\r\n                } else {\r\n                    saveToDownloadsLegacy(context, filename, decryptedStream)\r\n                }\r\n\r\n                Handler(Looper.getMainLooper()).post {\r\n                    if (savedPath != null) {\r\n                        Toast.makeText(context, \"✅ Downloaded to: $savedPath\", Toast.LENGTH_LONG).show()\r\n                        showDownloadNotification(context, savedPath, filename, mimeType)\r\n                    } else {\r\n                        Toast.makeText(context, \"❌ Failed to save file\", Toast.LENGTH_LONG).show()\r\n                    }\r\n                    onComplete()\r\n                }\r\n            } catch (e: Exception) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"❌ File decryption failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                    onComplete()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nprivate fun deleteAllDownloadsByNameBlocking(context: Context, fileName: String, timeoutMs: Long = 2000) {\r\n    // Only call this for API 29+\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) return\r\n\r\n    val resolver = context.contentResolver\r\n    val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n    val startTime = System.currentTimeMillis()\r\n    while (true) {\r\n        var found = false\r\n        val cursor = resolver.query(\r\n            collection,\r\n            arrayOf(MediaStore.Downloads._ID, MediaStore.Downloads.DISPLAY_NAME),\r\n            \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n            arrayOf(fileName),\r\n            null\r\n        )\r\n        cursor?.use {\r\n            val idCol = cursor.getColumnIndexOrThrow(MediaStore.Downloads._ID)\r\n            while (cursor.moveToNext()) {\r\n                found = true\r\n                val id = cursor.getLong(idCol)\r\n                val uri = ContentUris.withAppendedId(collection, id)\r\n                resolver.delete(uri, null, null)\r\n            }\r\n        }\r\n        if (!found) break\r\n        if (System.currentTimeMillis() - startTime > timeoutMs) break\r\n        Thread.sleep(100)\r\n    }\r\n}\r\n\r\nprivate fun saveToDownloadsQAndAbove(\r\n    context: Context,\r\n    filename: String,\r\n    mimeType: String,\r\n    inputStream: InputStream,\r\n    size: Long\r\n): String? {\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) return null\r\n    val resolver = context.contentResolver\r\n    val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n    try {\r\n        // Robust delete before insert, blocking until gone or timeout\r\n        deleteAllDownloadsByNameBlocking(context, filename)\r\n        val values = ContentValues().apply {\r\n            put(MediaStore.Downloads.DISPLAY_NAME, filename)\r\n            put(MediaStore.Downloads.MIME_TYPE, mimeType)\r\n            put(MediaStore.Downloads.IS_PENDING, 1)\r\n            if (size > 0) put(MediaStore.Downloads.SIZE, size)\r\n        }\r\n        val fileUri = resolver.insert(collection, values)\r\n        if (fileUri != null) {\r\n            resolver.openOutputStream(fileUri)?.use { output ->\r\n                val buffer = ByteArray(8192)\r\n                var len: Int\r\n                while (inputStream.read(buffer).also { len = it } != -1) {\r\n                    output.write(buffer, 0, len)\r\n                }\r\n            }\r\n            values.clear()\r\n            values.put(MediaStore.Downloads.IS_PENDING, 0)\r\n            resolver.update(fileUri, values, null, null)\r\n            return fileUri.toString()\r\n        } else {\r\n            // Last resort: MediaStore may still have a ghost file; check if file now exists\r\n            val cursor = resolver.query(\r\n                collection,\r\n                arrayOf(MediaStore.Downloads._ID),\r\n                \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n                arrayOf(filename),\r\n                null\r\n            )\r\n            val exists = cursor?.moveToFirst() == true\r\n            cursor?.close()\r\n            return if (exists) \"mediastore://found/$filename\" else null\r\n        }\r\n    } catch (e: Exception) {\r\n        e.printStackTrace()\r\n        // Last resort: MediaStore error, but maybe file is present\r\n        val cursor = resolver.query(\r\n            collection,\r\n            arrayOf(MediaStore.Downloads._ID),\r\n            \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n            arrayOf(filename),\r\n            null\r\n        )\r\n        val exists = cursor?.moveToFirst() == true\r\n        cursor?.close()\r\n        return if (exists) \"mediastore://found/$filename\" else null\r\n    }\r\n}\r\n\r\n\r\nprivate fun saveToDownloadsLegacy(\r\n    context: Context,\r\n    filename: String,\r\n    inputStream: InputStream\r\n): String? {\r\n    val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n    if (!downloadsDir.exists()) downloadsDir.mkdirs()\r\n    val outFile = File(downloadsDir, filename)\r\n    if (outFile.exists()) outFile.delete()\r\n    return try {\r\n        inputStream.use { input ->\r\n            outFile.outputStream().use { output ->\r\n                val buffer = ByteArray(8192)\r\n                var len: Int\r\n                while (input.read(buffer).also { len = it } != -1) {\r\n                    output.write(buffer, 0, len)\r\n                }\r\n            }\r\n        }\r\n        outFile.absolutePath\r\n    } catch (e: Exception) {\r\n        e.printStackTrace()\r\n        null\r\n    }\r\n}\r\n\r\nfun sendToServer(context: Context, text: String, ip: String, password: String, onStatusChange: (Boolean) -> Unit = {})\r\n {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"❗ No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onStatusChange(false)\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n     val encryptedText = encryptAESCBC(text, password)\r\n     val requestBody = FormBody.Builder().add(\"clipboard\", encryptedText).build()\r\n\r\n     val request = Request.Builder()\r\n        .url(\"http://$ip:8000/clipboard\")\r\n        .post(requestBody)\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                onStatusChange(false) // Notify failure\r\n                Toast.makeText(context, \"❌ Failed to sync: ${e.localizedMessage}\", Toast.LENGTH_LONG).show()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                val isSuccess = response.isSuccessful\r\n                onStatusChange(isSuccess)  // Pass status as Boolean\r\n\r\n                if (isSuccess) {\r\n                    Toast.makeText(context, \"✅ Clipboard synced\", Toast.LENGTH_SHORT).show()\r\n                } else {\r\n                    Toast.makeText(context, \"⚠️ Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun fetchClipboardFromServer(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    clipboardManager: ClipboardManager,\r\n    addToHistory: (String) -> Unit,\r\n    onComplete: () -> Unit\r\n) {\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/clipboard\")\r\n        .get()\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    val client = OkHttpClient()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"❌ Fetch failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            response.use {\r\n                if (!it.isSuccessful) {\r\n                    Handler(Looper.getMainLooper()).post {\r\n                        Toast.makeText(context, \"⚠️ Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                        onComplete()\r\n                    }\r\n                    return\r\n                }\r\n\r\n                val bodyString = it.body?.string()\r\n                val json = JSONObject(bodyString)\r\n                val isFile = json.optBoolean(\"is_file\", false)\r\n\r\n                if (isFile) {\r\n                    val filename = json.optString(\"filename\", \"fetched_file\")\r\n                    downloadFileFromClipboard(context, ip, password, filename, onComplete)\r\n                } else {\r\n                    val encryptedText = json.getString(\"clipboard\")\r\n                    val text = decryptAESCBC(encryptedText, password)\r\n                    Handler(Looper.getMainLooper()).post {\r\n                        clipboardManager.setPrimaryClip(ClipData.newPlainText(\"label\", text))\r\n                        addToHistory(text)\r\n                        Toast.makeText(context, \"📋 Clipboard updated\", Toast.LENGTH_SHORT).show()\r\n                        onComplete()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\nfun downloadFileFromClipboard(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    filename: String,\r\n    onComplete: () -> Unit\r\n) {\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download_clipboard_file\")\r\n        .get()\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n    val client = OkHttpClient()\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"❌ Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful || response.body == null) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"⚠️ Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onComplete()\r\n                }\r\n                return\r\n            }\r\n            try {\r\n                val encryptedStream = response.body!!.byteStream()\r\n                // --- Patch: decode base64 on the fly ---\r\n                val b64Stream = Base64InputStream(encryptedStream, android.util.Base64.DEFAULT)\r\n\r\n                // Read salt + iv headers (first 32 bytes) from the decoded stream\r\n                val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n                var read = 0\r\n                while (read < header.size) {\r\n                    val r = b64Stream.read(header, read, header.size - read)\r\n                    if (r == -1) throw IOException(\"Unexpected EOF in header\")\r\n                    read += r\r\n                }\r\n                val salt = header.copyOfRange(0, SALT_SIZE)\r\n                val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n                val key = deriveKey(password, salt)\r\n                val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n                cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n                val decryptedStream = CipherInputStream(b64Stream, cipher)\r\n\r\n                val mimeType = URLConnection.guessContentTypeFromName(filename) ?: \"application/octet-stream\"\r\n                val savedPath: String? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    saveToDownloadsQAndAbove(context, filename, mimeType, decryptedStream, -1)\r\n                } else {\r\n                    saveToDownloadsLegacy(context, filename, decryptedStream)\r\n                }\r\n                Handler(Looper.getMainLooper()).post {\r\n                    if (savedPath != null) {\r\n                        Toast.makeText(context, \"✅ File downloaded: $filename\", Toast.LENGTH_SHORT).show()\r\n                    } else {\r\n                        Toast.makeText(context, \"❌ Failed to save file\", Toast.LENGTH_LONG).show()\r\n                    }\r\n                    onComplete()\r\n                }\r\n            } catch (e: Exception) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"❌ File decryption failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                    onComplete()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        // Request notification permission for Android 13+ (API 33+)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\r\n            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS)\r\n                != PackageManager.PERMISSION_GRANTED\r\n            ) {\r\n                requestPermissions(arrayOf(android.Manifest.permission.POST_NOTIFICATIONS), 123)\r\n            }\r\n        }\r\n        setContent { ClipboardSyncApp() }\r\n        checkOverlayPermission()\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n\r\n        val prefs = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n\r\n        if (intent.getBooleanExtra(\"syncNow\", false)) {\r\n            Handler(Looper.getMainLooper()).postDelayed({\r\n                syncClipboardFromActivity()\r\n                intent.removeExtra(\"syncNow\")\r\n            }, 50)\r\n        }\r\n\r\n        if (intent.getBooleanExtra(\"fetchNow\", false)) {\r\n            Handler(Looper.getMainLooper()).postDelayed({\r\n                val clipboardManager = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n                val password = prefs.getString(\"password\", \"\") ?: \"\"\r\n\r\n                fetchClipboardFromServer(\r\n                    context = this,\r\n                    ip = prefs.getString(\"server_ip\", \"\") ?: \"\",\r\n                    password = password,\r\n                    clipboardManager = clipboardManager,\r\n                    addToHistory = { _ -> }, // assuming you have this function\r\n                    onComplete = {\r\n                        Handler(Looper.getMainLooper()).postDelayed({\r\n                            moveTaskToBack(true)\r\n                        }, 1000)\r\n                    }\r\n                )\r\n                intent.removeExtra(\"fetchNow\")\r\n                Handler(Looper.getMainLooper()).postDelayed({\r\n                    moveTaskToBack(true)\r\n                }, 1000) // ✅ same delay as sync\r\n            }, 50)\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private fun syncClipboardFromActivity() {\r\n        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n        val clip = clipboard.primaryClip\r\n        val text = clip?.getItemAt(0)?.text?.toString()\r\n        val prefs = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n        val ip = prefs.getString(\"server_ip\", \"\") ?: \"\"\r\n\r\n        if (!text.isNullOrEmpty()) {\r\n            val password = prefs.getString(\"server_password\", \"\") ?: \"\"\r\n            sendToServer(this, text, ip, password)\r\n        } else {\r\n            Toast.makeText(this, \"\\uD83D\\uDCCB Clipboard is empty\", Toast.LENGTH_SHORT).show()\r\n        }\r\n\r\n        Handler(Looper.getMainLooper()).postDelayed({\r\n            moveTaskToBack(true)\r\n        }, 1000)\r\n    }\r\n\r\n    private fun checkOverlayPermission() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            if (!Settings.canDrawOverlays(this)) {\r\n                val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:$packageName\"))\r\n                startActivity(intent)\r\n            } else {\r\n                startOverlayService()\r\n            }\r\n        } else {\r\n            startOverlayService()\r\n        }\r\n    }\r\n\r\n    private fun startOverlayService() {\r\n        val intent = Intent(this, OverlayService::class.java)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent)\r\n        else startService(intent)\r\n\r\n        Toast.makeText(this, \"\\u2705 Overlay service started\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n",
  "Toast",
  "def derive_key(password: str, salt: bytes) -> bytes:\r\n    \"\"\"Derive a key from password and salt using PBKDF2 (HMAC-SHA256).\"\"\"\r\n    return PBKDF2(password, salt, dkLen=KEY_LEN, count=PBKDF2_ITER, hmac_hash_module=SHA256)",
  "paste",
  "\"clipboard\": encrypt_text(clipboard_text, PASSWORD),",
  "Fetch Clipboard",
  "Saving",
  "Saving file",
  "file",
  "C:\\Users\\Prasen\\AndroidStudioProjects\\ClipboardSync\\dist\\received_files",
  " job search ",
  "search ",
  "Hello,\n\nWe appreciate your interest in Coditas and the time you've invested in\napplying for the opening.\n\nUnfortunately, we could not move ahead with your candidature. However,\nI  would like to thank you for giving us the opportunity to learn\nabout your skills and accomplishments.\n\nThis is not the end of the road. We hope you'll keep us in mind as we\nencourage you to apply again for a relevant opening after 3 months. We\nwish you good luck with your job search and future endeavors.\n\nYou can also follow us on social media for the latest job openings.",
  "UPLOAD_DIR.mkdir(exist_ok=True)\r\n",
  "https://computechstore.in/product/intel-core-i5-12400f-processor/",
  "windowManager = getSystemSer",
  "fetchView = AppCompatImageView(this).apply {\r\n    setImageResource(R.drawable.ic_clipboard_sync)\r\n    isClickable = true\r\n    rotation = 180f // visually points downward\r\n}\r\n",
  "fetchView = AppCompatImageView(this).apply {\r\n    setImageResource(R.drawable.ic_clipboard_sync)\r\n    isClickable = true\r\n    rotation = 180f // visually points downward\r\n}",
  "mini"
]