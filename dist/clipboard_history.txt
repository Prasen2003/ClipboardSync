[
  "Card(\r\n    modifier = Modifier.fillMaxWidth(),\r\n    colors = CardDefaults.cardColors(containerColor = Color(0xFF37474F)),\r\n    shape = RoundedCornerShape(8.dp),\r\n    elevation = CardDefaults.cardElevation(4.dp)\r\n) {\r\n    Column(modifier = Modifier.padding(16.dp)) {\r\n\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.SpaceBetween,\r\n            verticalAlignment = Alignment.CenterVertically\r\n        ) {\r\n            Text(\r\n                text = \"Connection Settings\",\r\n                fontSize = 18.sp,\r\n                color = Color.White\r\n            )\r\n\r\n            Text(\r\n                text = if (isConnected) \"🟢 Connected\" else \"🔴 Disconnected\",\r\n                color = if (isConnected) Color.Green else Color.Red,\r\n                fontSize = 14.sp\r\n            )\r\n        }\r\n\r\n        Spacer(modifier = Modifier.height(12.dp))\r\n\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(8.dp),\r\n            verticalAlignment = Alignment.CenterVertically\r\n        ) {\r\n            TextField(\r\n                value = ipAddress,\r\n                onValueChange = {\r\n                    ipAddress = it\r\n                    saveIp(it)\r\n                },\r\n                label = { Text(\"Server IP Address\", color = Color.White) },\r\n                singleLine = true,\r\n                modifier = Modifier.weight(1f),\r\n                colors = TextFieldDefaults.colors(\r\n                    focusedTextColor = Color.White,\r\n                    unfocusedTextColor = Color.White,\r\n                    focusedContainerColor = Color(0xFF455A64),\r\n                    unfocusedContainerColor = Color(0xFF455A64),\r\n                    focusedLabelColor = Color.White,\r\n                    unfocusedLabelColor = Color.White,\r\n                    focusedIndicatorColor = Color.White,\r\n                    unfocusedIndicatorColor = Color.White,\r\n                    cursorColor = Color.White\r\n                )\r\n            )\r\n\r\n            Button(\r\n                onClick = {\r\n                    discoverService(context) {\r\n                        ipAddress = it\r\n                        saveIp(it)\r\n                        Toast.makeText(context, \"🔄 IP updated to $it\", Toast.LENGTH_SHORT).show()\r\n                    }\r\n                },\r\n                modifier = Modifier\r\n                    .height(56.dp)\r\n                    .width(56.dp),\r\n                shape = RoundedCornerShape(8.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                ),\r\n                contentPadding = PaddingValues(0.dp)\r\n            ) {\r\n                Text(\"🔄\", fontSize = 22.sp)\r\n            }\r\n        }\r\n\r\n        Spacer(modifier = Modifier.height(8.dp))\r\n\r\n        TextField(\r\n            value = password,\r\n            onValueChange = {\r\n                password = it\r\n                savePassword(it)\r\n            },\r\n            label = { Text(\"Server Password\", color = Color.White) },\r\n            singleLine = true,\r\n            modifier = Modifier.fillMaxWidth(),\r\n            visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),\r\n            trailingIcon = {\r\n                IconButton(onClick = { passwordVisible = !passwordVisible }) {\r\n                    Icon(\r\n                        imageVector = if (passwordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility,\r\n                        contentDescription = if (passwordVisible) \"Hide password\" else \"Show password\",\r\n                        tint = Color.White\r\n                    )\r\n                }\r\n            },\r\n            colors = TextFieldDefaults.colors(\r\n                focusedTextColor = Color.White,\r\n                unfocusedTextColor = Color.White,\r\n                focusedContainerColor = Color(0xFF455A64),\r\n                unfocusedContainerColor = Color(0xFF455A64),\r\n                focusedLabelColor = Color.White,\r\n                unfocusedLabelColor = Color.White,\r\n                focusedIndicatorColor = Color.White,\r\n                unfocusedIndicatorColor = Color.White,\r\n                cursorColor = Color.White\r\n            )\r\n        )\r\n    }\r\n}\r\n",
  "Google",
  "journal paper",
  "192.168.174.183",
  "174.183",
  " String?",
  "fun saveFileToDownloads(\r\n    context: Context,\r\n    filename: String,\r\n    mimeType: String,\r\n    inputStream: InputStream,\r\n    size: Long\r\n): String? {\r\n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n        // API 29+\r\n        val values = ContentValues().apply {\r\n            put(MediaStore.Downloads.DISPLAY_NAME, filename)\r\n            put(MediaStore.Downloads.MIME_TYPE, mimeType)\r\n            put(MediaStore.Downloads.IS_PENDING, 1)\r\n        }\r\n\r\n        val resolver = context.contentResolver\r\n        val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n        val fileUri = resolver.insert(collection, values)\r\n\r\n        if (fileUri != null) {\r\n            resolver.openOutputStream(fileUri)?.use { output ->\r\n                inputStream.copyTo(output)\r\n            }\r\n            values.clear()\r\n            values.put(MediaStore.Downloads.IS_PENDING, 0)\r\n            resolver.update(fileUri, values, null, null)\r\n            return fileUri.toString()\r\n        } else {\r\n            null\r\n        }\r\n    } else {\r\n        // Below API 29\r\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n        if (!downloadsDir.exists()) downloadsDir.mkdirs()\r\n        val file = File(downloadsDir, filename)\r\n        inputStream.use { input ->\r\n            file.outputStream().use { output ->\r\n                input.copyTo(output)\r\n            }\r\n        }\r\n        return file.absolutePath\r\n    }\r\n}\r\n",
  "fun downloadFileFromServer(\r\n    context: Context,\r\n    filename: String,\r\n    ip: String,\r\n    password: String\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"❗ No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download/$filename\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"❌ Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"⚠️ Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n                return\r\n            }\r\n\r\n            val inputStream = response.body?.byteStream()\r\n            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n            val outFile = File(downloadsDir, filename)\r\n\r\n            inputStream?.use { input ->\r\n                outFile.outputStream().use { output ->\r\n                    input.copyTo(output)\r\n                }\r\n            }\r\n\r\n            val fileUri = FileProvider.getUriForFile(\r\n                context,\r\n                context.packageName + \".provider\",\r\n                outFile\r\n            )\r\n\r\n            // Notification\r\n            val openIntent = Intent(Intent.ACTION_VIEW).apply {\r\n                setDataAndType(fileUri, \"application/octet-stream\")\r\n                flags = Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK\r\n            }\r\n\r\n            val pendingIntent = PendingIntent.getActivity(\r\n                context,\r\n                0,\r\n                openIntent,\r\n                PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT\r\n            )\r\n\r\n            val channelId = \"download_channel\"\r\n            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                val channel = NotificationChannel(channelId, \"Downloads\", NotificationManager.IMPORTANCE_DEFAULT)\r\n                notificationManager.createNotificationChannel(channel)\r\n            }\r\n\r\n            val notification = NotificationCompat.Builder(context, channelId)\r\n                .setContentTitle(\"File downloaded\")\r\n                .setContentText(\"Tap to open: $filename\")\r\n                .setSmallIcon(android.R.drawable.stat_sys_download_done)\r\n                .setContentIntent(pendingIntent)\r\n                .setAutoCancel(true)\r\n                .build()\r\n\r\n            notificationManager.notify(1, notification)\r\n\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"✅ Downloaded to: ${outFile.absolutePath}\", Toast.LENGTH_LONG).show()\r\n            }\r\n        }\r\n    })\r\n}\r\n",
  "val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n",
  "def show_set_password_window(icon=None, item=None):\r\n    def save_new_password():\r\n        global PASSWORD\r\n        new_pass = entry.get().strip()\r\n        if new_pass:\r\n            PASSWORD = new_pass\r\n            save_config()\r\n            print(\"🔐 Password updated.\")\r\n            win.destroy()\r\n\r\n    def toggle_password_visibility():\r\n        if show_var.get():\r\n            entry.config(show=\"\")\r\n        else:\r\n            entry.config(show=\"*\")\r\n\r\n    global tk_window\r\n    if tk_window and tk_window.winfo_exists():\r\n        tk_window.lift()\r\n        return\r\n\r\n    win = tk.Toplevel(root)\r\n    win.title(\"Set Server Password\")\r\n    win.geometry(\"300x180\")\r\n    win.resizable(False, False)\r\n\r\n    ttk.Label(win, text=\"Enter new password:\", font=(\"Segoe UI\", 11)).pack(pady=(10, 5))\r\n    \r\n    entry = ttk.Entry(win, show=\"*\", font=(\"Segoe UI\", 11))\r\n    entry.pack(pady=5, padx=20, fill=\"x\")\r\n    entry.insert(0, PASSWORD)\r\n\r\n    show_var = tk.BooleanVar(value=False)\r\n    show_checkbox = ttk.Checkbutton(win, text=\"Show Password\", variable=show_var, command=toggle_password_visibility)\r\n    show_checkbox.pack(pady=(0, 10))\r\n\r\n    ttk.Button(win, text=\"Save\", command=save_new_password).pack(pady=10)\r\n",
  "offered",
  "Google offered ",
  "n = 5\na=[0,1]\nfor i in range(n):\n    a.append((a[-1]+a[-2]))\nprint(a)\n",
  "IoT Gesture System (Ultrasonic Sensors)  Developed a gesture-based control system using Arduino ultrasonic sensors and Python.  Implemented real-time distance sensing with noise handling and timeout safety.  Built a Tkinter GUI to simulate keyboard inputs (e.g., media control, custom inputs).  Enabled customizable key bindings, sensor toggles, and profile switching.  Used moving average filtering and serial communication for smooth, accurate gesture detection. "
]