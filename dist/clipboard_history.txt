[
  "items(historyState.value) { item ->\r\n    val isFileHistory = item.startsWith(\"‚¨ÜÔ∏è File uploaded:\") || item.startsWith(\"‚¨áÔ∏è File downloaded:\")\r\n    Row(\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .padding(vertical = 6.dp)\r\n            .clickable { selectedItem = item },\r\n        horizontalArrangement = Arrangement.SpaceBetween,\r\n        verticalAlignment = Alignment.CenterVertically\r\n    ) {\r\n        Text(\r\n            item.take(50).replace(\"\\n\", \" \"),\r\n            fontSize = 14.sp,\r\n            color = Color.White,\r\n            modifier = Modifier.weight(1f)\r\n        )\r\n        Row {\r\n            // Only show copy button for non-file entries\r\n            if (!isFileHistory) {\r\n                IconButton(onClick = {\r\n                    val clip = ClipData.newPlainText(\"Copied\", item)\r\n                    clipboardManager.setPrimaryClip(clip)\r\n                    Toast.makeText(context, \"üìã Copied to clipboard\", Toast.LENGTH_SHORT)\r\n                        .show()\r\n                }) {\r\n                    Text(\"üìã\", color = Color.White)\r\n                }\r\n            }\r\n            IconButton(onClick = { deleteFromHistory(item) }) {\r\n                Text(\"üóëÔ∏è\", color = Color.White)\r\n            }\r\n        }\r\n    }\r\n}",
  "‚¨ÜÔ∏è File uploaded: image:184854.jpg",
  "val fileLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\r\n        uri?.let {\r\n            uploadFileToServer(\r\n                context,\r\n                it,\r\n                ipAddress,\r\n                password,\r\n                onUploadingChanged = { uploading ->\r\n                    uploadingCount = when {\r\n                        uploading -> uploadingCount + 1\r\n                        uploadingCount > 0 -> uploadingCount - 1\r\n                        else -> 0\r\n                    }\r\n                },\r\n                onProgress = { progress -> uploadProgress = progress },\r\n                onHistory = { filename ->\r\n                    addFileToHistory(filename, \"Uploaded\")\r\n                }\r\n            )\r\n        }\r\n    }",
  "python compiler",
  "8500g",
  "github copilot",
  "package com.example.clipboardsync\r\n\r\nimport android.content.*\r\nimport android.net.nsd.*\r\nimport android.os.*\r\nimport android.provider.Settings\r\nimport android.widget.Toast\r\nimport androidx.activity.ComponentActivity\r\nimport androidx.activity.compose.setContent\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.unit.sp\r\nimport okhttp3.*\r\nimport org.json.JSONArray\r\nimport org.json.JSONObject\r\nimport java.io.IOException\r\nimport androidx.compose.foundation.clickable\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.verticalScroll\r\nimport android.content.ClipData\r\nimport android.content.Context\r\nimport android.content.SharedPreferences\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.lazy.items\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport kotlinx.coroutines.*\r\nimport okhttp3.OkHttpClient\r\nimport okhttp3.Request\r\nimport java.util.concurrent.TimeUnit\r\nimport androidx.activity.compose.rememberLauncherForActivityResult\r\nimport androidx.activity.result.contract.ActivityResultContracts\r\nimport android.net.Uri\r\nimport android.os.Handler\r\nimport android.os.Looper\r\nimport java.io.File\r\nimport okhttp3.MediaType.Companion.toMediaTypeOrNull\r\nimport okhttp3.RequestBody.Companion.asRequestBody\r\nimport android.webkit.MimeTypeMap\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material3.ButtonDefaults\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.foundation.*\r\nimport androidx.compose.material3.TextFieldDefaults\r\nimport kotlinx.coroutines.delay\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Visibility\r\nimport androidx.compose.material.icons.filled.VisibilityOff\r\nimport androidx.compose.ui.text.input.PasswordVisualTransformation\r\nimport androidx.compose.ui.text.input.VisualTransformation\r\nimport android.content.ContentValues\r\nimport android.os.Build\r\nimport android.provider.MediaStore\r\nimport java.io.InputStream\r\nimport java.net.URLConnection\r\nimport android.os.Environment\r\nimport javax.crypto.Cipher\r\nimport javax.crypto.spec.SecretKeySpec\r\nimport java.security.MessageDigest\r\nimport android.util.Base64\r\nimport java.security.SecureRandom\r\nimport javax.crypto.SecretKeyFactory\r\nimport javax.crypto.spec.IvParameterSpec\r\nimport javax.crypto.spec.PBEKeySpec\r\nimport javax.crypto.CipherInputStream\r\nimport android.util.Base64InputStream\r\nimport androidx.core.app.NotificationCompat\r\nimport androidx.core.app.NotificationManagerCompat\r\nimport android.app.PendingIntent\r\nimport android.content.Intent\r\nimport androidx.core.content.FileProvider\r\nimport android.content.pm.PackageManager\r\nimport androidx.core.app.ActivityCompat\r\nimport android.app.NotificationChannel\r\nimport android.app.NotificationManager\r\nimport androidx.activity.result.ActivityResultLauncher\r\nimport android.util.Log\r\nimport java.io.FileOutputStream\r\nimport java.io.OutputStream\r\nimport javax.crypto.CipherOutputStream\r\nimport androidx.compose.material3.LinearProgressIndicator\r\nimport androidx.compose.ui.text.font.FontWeight\r\nimport okio.*\r\nimport okhttp3.ResponseBody\r\nimport android.content.BroadcastReceiver\r\n\r\nclass ProgressResponseBody(\r\n    private val responseBody: ResponseBody,\r\n    private val onProgress: (Float) -> Unit\r\n) : ResponseBody() {\r\n    private var bufferedSource: BufferedSource? = null\r\n\r\n    override fun contentType() = responseBody.contentType()\r\n    override fun contentLength() = responseBody.contentLength()\r\n\r\n    override fun source(): BufferedSource {\r\n        if (bufferedSource == null) {\r\n            bufferedSource = source(responseBody.source()).buffer()\r\n        }\r\n        return bufferedSource!!\r\n    }\r\n\r\n    private fun source(source: Source): Source {\r\n        val totalBytes = contentLength().takeIf { it > 0 } ?: 1L\r\n        var totalBytesRead = 0L\r\n\r\n        return object : ForwardingSource(source) {\r\n            override fun read(sink: Buffer, byteCount: Long): Long {\r\n                val bytesRead = super.read(sink, byteCount)\r\n                if (bytesRead != -1L) {\r\n                    totalBytesRead += bytesRead\r\n                    onProgress(totalBytesRead / totalBytes.toFloat())\r\n                }\r\n                return bytesRead\r\n            }\r\n        }\r\n    }\r\n}\r\nclass ProgressRequestBody(\r\n    private val file: File,\r\n    private val contentType: String,\r\n    private val onProgress: (Float) -> Unit\r\n) : RequestBody() {\r\n\r\n    override fun contentType() = contentType.toMediaTypeOrNull()\r\n    override fun contentLength() = file.length()\r\n\r\n    override fun writeTo(sink: okio.BufferedSink) {\r\n        val total = file.length().toFloat().coerceAtLeast(1f)\r\n        file.inputStream().use { input ->\r\n            val buffer = ByteArray(DEFAULT_BUFFER_SIZE)\r\n            var uploaded = 0L\r\n            var read: Int\r\n            while (input.read(buffer).also { read = it } != -1) {\r\n                sink.write(buffer, 0, read)\r\n                uploaded += read\r\n                onProgress(uploaded / total)\r\n            }\r\n        }\r\n    }\r\n}\r\nclass ProgressInputStream(\r\n    private val wrapped: InputStream,\r\n    private val totalBytes: Long,\r\n    private val onProgress: (Float) -> Unit\r\n) : InputStream() {\r\n    private var bytesRead = 0L\r\n    override fun read(): Int {\r\n        val byte = wrapped.read()\r\n        if (byte != -1) {\r\n            bytesRead++\r\n            onProgress(bytesRead / totalBytes.toFloat())\r\n        }\r\n        return byte\r\n    }\r\n    override fun read(b: ByteArray, off: Int, len: Int): Int {\r\n        val n = wrapped.read(b, off, len)\r\n        if (n > 0) {\r\n            bytesRead += n\r\n            onProgress(bytesRead / totalBytes.toFloat())\r\n        }\r\n        return n\r\n    }\r\n    override fun close() = wrapped.close()\r\n}\r\n@Composable\r\nfun ClipboardSyncApp() {\r\n    val context = LocalContext.current\r\n    val clipboardManager = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n    val prefs = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n    var downloadingCount by remember { mutableStateOf(0) }\r\n    val isDownloading = downloadingCount > 0\r\n    var uploadingCount by remember { mutableStateOf(0) }\r\n    val isUploading = uploadingCount > 0\r\n    var showFileDialog by remember { mutableStateOf(false) }\r\n    var lastText by remember { mutableStateOf(\"\") }\r\n    var ipAddress by remember { mutableStateOf(prefs.getString(\"server_ip\", \"\") ?: \"\") }\r\n    var history by remember { mutableStateOf(loadHistory(prefs)) }\r\n    var isConnected by remember { mutableStateOf(false) }\r\n    var password by remember { mutableStateOf(prefs.getString(\"server_password\", \"\") ?: \"\") }\r\n    var availableFiles by remember { mutableStateOf<List<String>>(emptyList()) }\r\n    val ip = prefs.getString(\"server_ip\", \"\") ?: \"\"\r\n    var clipboardHistory by remember { mutableStateOf(listOf<String>()) }\r\n    // PROGRESS STATES\r\n    var uploadProgress by remember { mutableStateOf<Float?>(null) }\r\n    var downloadProgress by remember { mutableStateOf<Float?>(null) }\r\n    val fileLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\r\n        uri?.let {\r\n            uploadFileToServer(\r\n                context,\r\n                it,\r\n                ipAddress,\r\n                password,\r\n                onUploadingChanged = { uploading ->\r\n                    uploadingCount = when {\r\n                        uploading -> uploadingCount + 1\r\n                        uploadingCount > 0 -> uploadingCount - 1\r\n                        else -> 0\r\n                    }\r\n                },\r\n                onProgress = { progress -> uploadProgress = progress }\r\n            )\r\n        }\r\n    }\r\n    val buttonColor = Color(0xFF546E7A)\r\n    val buttonTextColor = Color.White\r\n\r\n    fun savePassword(pass: String) = prefs.edit().putString(\"server_password\", pass).apply()\r\n    fun saveIp(ip: String) = prefs.edit().putString(\"server_ip\", ip).apply()\r\n\r\n    fun addToHistory(text: String) {\r\n        val newHistory = listOf(text) + history.filterNot { it == text }\r\n        history = newHistory.take(50)\r\n        prefs.edit().putString(\"clipboard_history\", JSONArray(newHistory).toString()).apply()\r\n    }\r\n\r\n    fun deleteFromHistory(item: String) {\r\n        history = history.filterNot { it == item }\r\n        prefs.edit().putString(\"clipboard_history\", JSONArray(history).toString()).apply()\r\n    }\r\n\r\n    LaunchedEffect(ipAddress) {\r\n        while (true) {\r\n            pingServer(context, ipAddress, password) { isConnected = it }\r\n            delay(5000)\r\n        }\r\n    }\r\n\r\n    LaunchedEffect(Unit) {\r\n        discoverService(context) {\r\n            ipAddress = it\r\n            saveIp(it)\r\n        }\r\n        clipboardManager.primaryClip?.getItemAt(0)?.text?.toString()?.let {\r\n            if (it.isNotBlank()) {\r\n                lastText = it\r\n                addToHistory(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    DisposableEffect(Unit) {\r\n        val listener = ClipboardManager.OnPrimaryClipChangedListener {\r\n            val text = clipboardManager.primaryClip?.getItemAt(0)?.text.toString()\r\n            if (text.isNotBlank() && text != lastText) {\r\n                lastText = text\r\n                addToHistory(text)\r\n                sendToServer(context, text, ipAddress, password)\r\n            }\r\n        }\r\n        clipboardManager.addPrimaryClipChangedListener(listener)\r\n        onDispose { clipboardManager.removePrimaryClipChangedListener(listener) }\r\n    }\r\n\r\n    var selectedItem by remember { mutableStateOf<String?>(null) }\r\n    var passwordVisible by remember { mutableStateOf(false) }\r\n\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .background(Color(0xFF263238)) // dark blue-grey\r\n            .padding(16.dp),\r\n        verticalArrangement = Arrangement.spacedBy(16.dp)\r\n    ) {\r\n        Card(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            colors = CardDefaults.cardColors(containerColor = Color(0xFF37474F)),\r\n            shape = RoundedCornerShape(8.dp),\r\n            elevation = CardDefaults.cardElevation(4.dp)\r\n        ) {\r\n            Column(modifier = Modifier.padding(16.dp)) {\r\n                Row(\r\n                    modifier = Modifier.fillMaxWidth(),\r\n                    horizontalArrangement = Arrangement.SpaceBetween,\r\n                    verticalAlignment = Alignment.CenterVertically\r\n                ) {\r\n                    Text(\r\n                        text = \"Connection Settings\",\r\n                        fontSize = 18.sp,\r\n                        color = Color.White\r\n                    )\r\n                    Text(\r\n                        text = if (isConnected) \"üü¢ Connected\" else \"üî¥ Disconnected\",\r\n                        color = if (isConnected) Color.Green else Color.Red,\r\n                        fontSize = 14.sp\r\n                    )\r\n                }\r\n                Spacer(modifier = Modifier.height(12.dp))\r\n                Row(\r\n                    modifier = Modifier.fillMaxWidth(),\r\n                    horizontalArrangement = Arrangement.spacedBy(8.dp),\r\n                    verticalAlignment = Alignment.CenterVertically\r\n                ) {\r\n                    TextField(\r\n                        value = ipAddress,\r\n                        onValueChange = {\r\n                            ipAddress = it\r\n                            saveIp(it)\r\n                        },\r\n                        label = { Text(\"Server IP Address\", color = Color.White) },\r\n                        singleLine = true,\r\n                        modifier = Modifier.weight(1f),\r\n                        colors = TextFieldDefaults.colors(\r\n                            focusedTextColor = Color.White,\r\n                            unfocusedTextColor = Color.White,\r\n                            focusedContainerColor = Color(0xFF455A64),\r\n                            unfocusedContainerColor = Color(0xFF455A64),\r\n                            focusedLabelColor = Color.White,\r\n                            unfocusedLabelColor = Color.White,\r\n                            focusedIndicatorColor = Color.White,\r\n                            unfocusedIndicatorColor = Color.White,\r\n                            cursorColor = Color.White\r\n                        )\r\n                    )\r\n                    Button(\r\n                        onClick = {\r\n                            discoverService(context) {\r\n                                ipAddress = it\r\n                                saveIp(it)\r\n                                Toast.makeText(context, \"üîÑ IP updated to $it\", Toast.LENGTH_SHORT).show()\r\n                            }\r\n                        },\r\n                        modifier = Modifier\r\n                            .height(56.dp)\r\n                            .width(56.dp),\r\n                        shape = RoundedCornerShape(8.dp),\r\n                        colors = ButtonDefaults.buttonColors(\r\n                            containerColor = buttonColor,\r\n                            contentColor = buttonTextColor\r\n                        ),\r\n                        contentPadding = PaddingValues(0.dp)\r\n                    ) {\r\n                        Text(\"üîÑ\", fontSize = 22.sp)\r\n                    }\r\n                }\r\n                Spacer(modifier = Modifier.height(8.dp))\r\n                TextField(\r\n                    value = password,\r\n                    onValueChange = {\r\n                        password = it\r\n                        savePassword(it)\r\n                    },\r\n                    label = { Text(\"Server Password\", color = Color.White) },\r\n                    singleLine = true,\r\n                    modifier = Modifier.fillMaxWidth(),\r\n                    visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),\r\n                    trailingIcon = {\r\n                        IconButton(onClick = { passwordVisible = !passwordVisible }) {\r\n                            Icon(\r\n                                imageVector = if (passwordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility,\r\n                                contentDescription = if (passwordVisible) \"Hide password\" else \"Show password\",\r\n                                tint = Color.White\r\n                            )\r\n                        }\r\n                    },\r\n                    colors = TextFieldDefaults.colors(\r\n                        focusedTextColor = Color.White,\r\n                        unfocusedTextColor = Color.White,\r\n                        focusedContainerColor = Color(0xFF455A64),\r\n                        unfocusedContainerColor = Color(0xFF455A64),\r\n                        focusedLabelColor = Color.White,\r\n                        unfocusedLabelColor = Color.White,\r\n                        focusedIndicatorColor = Color.White,\r\n                        unfocusedIndicatorColor = Color.White,\r\n                        cursorColor = Color.White\r\n                    )\r\n                )\r\n            }\r\n        }\r\n        Divider(color = Color.Gray)\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(12.dp)\r\n        ) {\r\n            Button(\r\n                onClick = {\r\n                    clipboardManager.primaryClip?.getItemAt(0)?.text?.toString()?.let { text ->\r\n                        lastText = text\r\n                        addToHistory(text)\r\n                        sendToServer(context, text, ipAddress, password)\r\n                    }\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"\\uD83D\\uDCE4 Sync Text\")\r\n            }\r\n\r\n        }\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(8.dp)\r\n        ) {\r\n            Button(\r\n                onClick = { fileLauncher.launch(\"*/*\") },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"üìÅ Send File\")\r\n            }\r\n            Button(\r\n                onClick = {\r\n                    downloadingCount += 1\r\n                    fetchClipboardFromServer(\r\n                        context = context,\r\n                        ip = ipAddress,\r\n                        password = password,\r\n                        clipboardManager = clipboardManager,\r\n                        addToHistory = { text -> clipboardHistory = clipboardHistory + text },\r\n                        onComplete = { downloadingCount = maxOf(downloadingCount - 1, 0) },\r\n                        onProgress = { progress -> downloadProgress = progress }\r\n                    )\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"üìÉ Fetch\")\r\n            }\r\n        }\r\n        if (showFileDialog) {\r\n            AlertDialog(\r\n                onDismissRequest = { showFileDialog = false },\r\n                title = { Text(\"Available Files\", color = Color.White) },\r\n                text = {\r\n                    Column(\r\n                        modifier = Modifier\r\n                            .heightIn(min = 100.dp, max = 400.dp)\r\n                            .verticalScroll(rememberScrollState())\r\n                    ) {\r\n                        if (availableFiles.isEmpty()) {\r\n                            Text(\"No files found\", color = Color.White)\r\n                        } else {\r\n                            availableFiles.forEach { file ->\r\n                                Row(\r\n                                    modifier = Modifier\r\n                                        .fillMaxWidth()\r\n                                        .clickable {\r\n                                            downloadingCount += 1\r\n                                            downloadFileFromServer(\r\n                                                context, file, ipAddress, password,\r\n                                                onComplete = { downloadingCount = maxOf(downloadingCount - 1, 0) },\r\n                                                onProgress = { progress -> downloadProgress = progress }\r\n                                            )\r\n                                            showFileDialog = false\r\n                                        }\r\n                                        .padding(vertical = 8.dp),\r\n                                    verticalAlignment = Alignment.CenterVertically\r\n                                ) {\r\n                                    Text(file, color = Color.White, modifier = Modifier.weight(1f))\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                confirmButton = {\r\n                    TextButton(onClick = { showFileDialog = false }) {\r\n                        Text(\"Close\", color = Color.White)\r\n                    }\r\n                },\r\n                containerColor = Color(0xFF37474F)\r\n            )\r\n        }\r\n        // --- Show upload/download progress ---\r\n        if (isUploading) {\r\n            Spacer(modifier = Modifier.height(8.dp))\r\n            Text(\"Uploading...\", fontSize = 14.sp, color = Color.White)\r\n            LinearProgressIndicator(\r\n                progress = uploadProgress ?: 0f,\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .height(4.dp),\r\n                color = Color(0xFF90CAF9)\r\n            )\r\n        }\r\n        if (isDownloading) {\r\n            Spacer(modifier = Modifier.height(4.dp))\r\n            Text(\"Downloading...\", fontSize = 14.sp, color = Color.White)\r\n            LinearProgressIndicator(\r\n                progress = downloadProgress ?: 0f,\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .height(4.dp),\r\n                color = Color(0xFF80CBC4)\r\n            )\r\n        }\r\n        Divider(color = Color.Gray)\r\n        Text(\"Clipboard History\", fontSize = 18.sp, color = Color.White)\r\n        LazyColumn(\r\n            modifier = Modifier\r\n                .fillMaxSize()\r\n                .padding(top = 2.dp)\r\n        ) {\r\n            items(history) { item ->\r\n                Row(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .padding(vertical = 6.dp)\r\n                        .clickable { selectedItem = item },\r\n                    horizontalArrangement = Arrangement.SpaceBetween,\r\n                    verticalAlignment = Alignment.CenterVertically\r\n                ) {\r\n                    Text(\r\n                        item.take(50).replace(\"\\n\", \" \"),\r\n                        fontSize = 14.sp,\r\n                        color = Color.White,\r\n                        modifier = Modifier.weight(1f)\r\n                    )\r\n                    Row {\r\n                        IconButton(onClick = {\r\n                            val clip = ClipData.newPlainText(\"Copied\", item)\r\n                            clipboardManager.setPrimaryClip(clip)\r\n                            Toast.makeText(context, \"üìã Copied to clipboard\", Toast.LENGTH_SHORT)\r\n                                .show()\r\n                        }) {\r\n                            Text(\"üìã\", color = Color.White)\r\n                        }\r\n                        IconButton(onClick = { deleteFromHistory(item) }) {\r\n                            Text(\"üóëÔ∏è\", color = Color.White)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Expanded History View Dialog\r\n    selectedItem?.let {\r\n        val scrollState = rememberScrollState()\r\n        AlertDialog(\r\n            onDismissRequest = { selectedItem = null },\r\n            title = { Text(\"Clipboard Entry\", color = Color.White) },\r\n            text = {\r\n                Column(\r\n                    modifier = Modifier\r\n                        .heightIn(min = 100.dp, max = 400.dp)\r\n                        .verticalScroll(scrollState)\r\n                        .padding(4.dp)\r\n                ) {\r\n                    Text(it, fontSize = 14.sp, color = Color.White)\r\n                }\r\n            },\r\n            confirmButton = {\r\n                TextButton(onClick = { selectedItem = null }) {\r\n                    Text(\"Close\", color = Color.White)\r\n                }\r\n            },\r\n            containerColor = Color(0xFF37474F)\r\n        )\r\n    }\r\n}\r\n\r\n// --- CONFIG --- //\r\nprivate const val PBKDF2_ITERATIONS = 10000\r\nprivate const val KEY_LENGTH = 256 // bits\r\nprivate const val SALT_SIZE = 16   // bytes\r\nprivate const val IV_SIZE = 16     // bytes\r\n\r\n// --- KEY DERIVATION --- //\r\nprivate fun deriveKey(password: String, salt: ByteArray): SecretKeySpec {\r\n    val factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\")\r\n    val spec = PBEKeySpec(password.toCharArray(), salt, PBKDF2_ITERATIONS, KEY_LENGTH)\r\n    val tmp = factory.generateSecret(spec)\r\n    return SecretKeySpec(tmp.encoded, \"AES\")\r\n}\r\n\r\n// --- RANDOM GENERATORS --- //\r\nprivate fun randomBytes(size: Int): ByteArray {\r\n    val bytes = ByteArray(size)\r\n    SecureRandom().nextBytes(bytes)\r\n    return bytes\r\n}\r\n\r\n// --- SECURE ENCRYPTION FOR TEXT --- //\r\nfun encryptAESCBC(text: String, password: String): String {\r\n    val salt = randomBytes(SALT_SIZE)\r\n    val iv = randomBytes(IV_SIZE)\r\n    val key = deriveKey(password, salt)\r\n\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\r\n    val encrypted = cipher.doFinal(text.toByteArray(Charsets.UTF_8))\r\n    // Output: salt + iv + ciphertext (all base64 encoded)\r\n    val out = ByteArray(salt.size + iv.size + encrypted.size)\r\n    System.arraycopy(salt, 0, out, 0, salt.size)\r\n    System.arraycopy(iv, 0, out, salt.size, iv.size)\r\n    System.arraycopy(encrypted, 0, out, salt.size + iv.size, encrypted.size)\r\n    return Base64.encodeToString(out, Base64.NO_WRAP)\r\n}\r\n\r\nfun decryptAESCBC(encrypted: String, password: String): String {\r\n    val decoded = Base64.decode(encrypted, Base64.NO_WRAP)\r\n    val salt = decoded.copyOfRange(0, SALT_SIZE)\r\n    val iv = decoded.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n    val ciphertext = decoded.copyOfRange(SALT_SIZE + IV_SIZE, decoded.size)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n    val decrypted = cipher.doFinal(ciphertext)\r\n    return String(decrypted, Charsets.UTF_8)\r\n}\r\n\r\n// --- SECURE ENCRYPTION FOR FILES (BYTES) --- //\r\n/**\r\n * Encrypts input stream using AES/CBC and writes output as [salt][iv]\r\n * Designed for large file support - does NOT load entire file in memory.\r\n */\r\nfun encryptStreamCBC(\r\n    input: InputStream,\r\n    output: OutputStream,\r\n    password: String,\r\n    bufferSize: Int = 8192\r\n) {\r\n    val salt = randomBytes(SALT_SIZE)\r\n    val iv = randomBytes(IV_SIZE)\r\n    output.write(salt)\r\n    output.write(iv)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\r\n    CipherOutputStream(output, cipher).use { cipherOut ->\r\n        val buffer = ByteArray(bufferSize)\r\n        var read: Int\r\n        while (input.read(buffer).also { read = it } != -1) {\r\n            cipherOut.write(buffer, 0, read)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Decrypts input stream (with [salt][iv]) and writes plaintext output.\r\n * Designed for large file support - does NOT load entire file in memory.\r\n */\r\nfun decryptStreamCBC(\r\n    input: InputStream,\r\n    output: OutputStream,\r\n    password: String,\r\n    bufferSize: Int = 8192\r\n) {\r\n    // Read salt + iv\r\n    val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n    var read = 0\r\n    while (read < header.size) {\r\n        val n = input.read(header, read, header.size - read)\r\n        if (n == -1) throw IllegalArgumentException(\"Invalid encrypted file (header too short)\")\r\n        read += n\r\n    }\r\n    val salt = header.copyOfRange(0, SALT_SIZE)\r\n    val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n    CipherInputStream(input, cipher).use { cipherIn ->\r\n        val buffer = ByteArray(bufferSize)\r\n        var len: Int\r\n        while (cipherIn.read(buffer).also { len = it } != -1) {\r\n            output.write(buffer, 0, len)\r\n        }\r\n    }\r\n}\r\n\r\nfun showDownloadNotification(context: Context, filePathOrUri: String, filename: String, mimeType: String) {\r\n    val channelId = \"clipboard_download_channel\"\r\n    val notificationId = 1001\r\n\r\n    // Create notification channel\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        val name = \"ClipboardSync Downloads\"\r\n        val descriptionText = \"Notifications for completed file downloads\"\r\n        val importance = NotificationManager.IMPORTANCE_DEFAULT\r\n        val channel = NotificationChannel(channelId, name, importance).apply {\r\n            description = descriptionText\r\n        }\r\n        val notificationManager: NotificationManager =\r\n            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n        notificationManager.createNotificationChannel(channel)\r\n    }\r\n\r\n    // Check notification permission for API 33+\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU &&\r\n        ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS)\r\n        != PackageManager.PERMISSION_GRANTED) {\r\n        return\r\n    }\r\n\r\n    // Use the correct URI\r\n    val fileUri: Uri = if (filePathOrUri.startsWith(\"content://\")) {\r\n        Uri.parse(filePathOrUri)\r\n    } else {\r\n        File(filePathOrUri).let { file ->\r\n            FileProvider.getUriForFile(context, context.packageName + \".provider\", file)\r\n        }\r\n    }\r\n\r\n    val openIntent = Intent(Intent.ACTION_VIEW).apply {\r\n        setDataAndType(fileUri, mimeType)\r\n        addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK)\r\n    }\r\n    // Wrap it in a chooser for best compatibility\r\n    val chooserIntent = Intent.createChooser(openIntent, \"Open with\")\r\n\r\n    val pendingIntent = PendingIntent.getActivity(\r\n        context, 0, chooserIntent,\r\n        PendingIntent.FLAG_UPDATE_CURRENT or\r\n                (if (Build.VERSION.SDK_INT >= 31) PendingIntent.FLAG_MUTABLE else 0)\r\n    )\r\n\r\n    val notification = NotificationCompat.Builder(context, channelId)\r\n        .setSmallIcon(android.R.drawable.stat_sys_download_done)\r\n        .setContentTitle(\"Download complete\")\r\n        .setContentText(filename)\r\n        .setPriority(NotificationCompat.PRIORITY_DEFAULT)\r\n        .setAutoCancel(true)\r\n        .addAction(android.R.drawable.ic_menu_view, \"Open\", pendingIntent)\r\n        .setContentIntent(pendingIntent)\r\n        .build()\r\n\r\n    NotificationManagerCompat.from(context).notify(notificationId, notification)\r\n}\r\n\r\nfun pingServer(context: Context, ip: String, password: String, onResult: (Boolean) -> Unit) {\r\n    if (ip.isBlank()) {\r\n        onResult(false)\r\n        return\r\n    }\r\n\r\n    CoroutineScope(Dispatchers.IO).launch {\r\n        try {\r\n            val client = OkHttpClient.Builder()\r\n                .callTimeout(2, TimeUnit.SECONDS)\r\n                .build()\r\n\r\n            val request = Request.Builder()\r\n                .url(\"http://$ip:8000/ping\")\r\n                .get()\r\n                .addHeader(\"X-Auth-Token\", password)\r\n                .build()\r\n\r\n            val response = client.newCall(request).execute()\r\n            onResult(response.isSuccessful)\r\n        } catch (e: Exception) {\r\n            onResult(false)\r\n        }\r\n    }\r\n}\r\n\r\nfun loadHistory(prefs: SharedPreferences): List<String> {\r\n    val json = prefs.getString(\"clipboard_history\", \"[]\")\r\n    return try {\r\n        val arr = JSONArray(json)\r\n        List(arr.length()) { i -> arr.getString(i) }\r\n    } catch (e: Exception) {\r\n        emptyList()\r\n    }\r\n}\r\n\r\nfun discoverService(context: Context, onFound: (String) -> Unit) {\r\n    val nsdManager = context.getSystemService(Context.NSD_SERVICE) as NsdManager\r\n    val serviceType = \"_http._tcp.\"\r\n    val serviceNamePrefix = \"ClipboardSyncServer\"\r\n    lateinit var discoveryListener: NsdManager.DiscoveryListener\r\n\r\n    discoveryListener = object : NsdManager.DiscoveryListener {\r\n        override fun onDiscoveryStarted(serviceType: String) {}\r\n        override fun onStopDiscoveryFailed(serviceType: String?, errorCode: Int) {}\r\n        override fun onStartDiscoveryFailed(serviceType: String?, errorCode: Int) {}\r\n        override fun onDiscoveryStopped(serviceType: String) {}\r\n        override fun onServiceFound(serviceInfo: NsdServiceInfo) {\r\n            if (serviceInfo.serviceName.contains(serviceNamePrefix)) {\r\n                nsdManager.resolveService(serviceInfo, object : NsdManager.ResolveListener {\r\n                    override fun onResolveFailed(serviceInfo: NsdServiceInfo?, errorCode: Int) {}\r\n                    override fun onServiceResolved(resolved: NsdServiceInfo) {\r\n                        val host = resolved.host.hostAddress\r\n                        if (host != null) {\r\n                            onFound(host)\r\n                            nsdManager.stopServiceDiscovery(discoveryListener)\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        override fun onServiceLost(serviceInfo: NsdServiceInfo) {}\r\n    }\r\n\r\n    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener)\r\n}\r\n\r\nfun uploadFileToServer(\r\n    context: Context,\r\n    uri: Uri,\r\n    ip: String,\r\n    password: String,\r\n    onUploadingChanged: (Boolean) -> Unit,\r\n    onProgress: (Float?) -> Unit = {} // <-- already present in your code\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        return\r\n    }\r\n    onUploadingChanged(true)\r\n    val contentResolver = context.contentResolver\r\n\r\n    val mimeType = contentResolver.getType(uri)\r\n    val extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType) ?: \"bin\"\r\n    var fileName = uri.lastPathSegment?.substringAfterLast('/') ?: \"upload\"\r\n    if (!fileName.contains('.')) fileName += \".$extension\"\r\n\r\n    val inputStream = contentResolver.openInputStream(uri) ?: return\r\n    val tempFile = File.createTempFile(\"upload\", null, context.cacheDir)\r\n    inputStream.use { input ->\r\n        tempFile.outputStream().use { output ->\r\n            encryptStreamCBC(input, output, password)\r\n        }\r\n    }\r\n\r\n    val progressBody = ProgressRequestBody(tempFile, \"application/octet-stream\") { progress ->\r\n        Handler(Looper.getMainLooper()).post { onProgress(progress) }\r\n    }\r\n\r\n    val multipartBody = MultipartBody.Builder()\r\n        .setType(MultipartBody.FORM)\r\n        .addFormDataPart(\"file\", fileName, progressBody)\r\n        .build()\r\n\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/upload\")\r\n        .post(multipartBody)\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    val client = OkHttpClient()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Upload failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onUploadingChanged(false)\r\n                onProgress(null)\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                if (response.isSuccessful) {\r\n                    Toast.makeText(context, \"‚úÖ File uploaded successfully\", Toast.LENGTH_SHORT).show()\r\n                } else {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Upload failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n                onUploadingChanged(false)\r\n                onProgress(null)\r\n            }\r\n        }\r\n    })\r\n}\r\nfun fetchFileListFromServer(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    onResult: (List<String>) -> Unit\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onResult(emptyList())\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/list-files\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Failed to get file list\", Toast.LENGTH_SHORT).show()\r\n                onResult(emptyList())\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onResult(emptyList())\r\n                }\r\n                return\r\n            }\r\n\r\n            val body = response.body?.string()\r\n            val fileList = try {\r\n                val json = JSONObject(body ?: \"{}\")\r\n                val filesArray = json.getJSONArray(\"files\")\r\n                List(filesArray.length()) { i -> filesArray.getString(i) }\r\n            } catch (e: Exception) {\r\n                emptyList()\r\n            }\r\n\r\n            Handler(Looper.getMainLooper()).post {\r\n                onResult(fileList)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun downloadFileFromServer(\r\n    context: Context,\r\n    filename: String,\r\n    ip: String,\r\n    password: String,\r\n    onComplete: () -> Unit = {},\r\n    onProgress: (Float?) -> Unit = {}   // <-- new parameter\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onProgress(null)\r\n        onComplete()\r\n        return\r\n    }\r\n    Log.d(\"ClipboardSync\", \"downloadFileFromServer CALLED for $filename\")\r\n    val baseName = filename.substringBeforeLast('.')\r\n    val ext = filename.substringAfterLast('.', \"\")\r\n    val suffixes = listOf(\"\") + (1..9).map { \" ($it)\" }\r\n    for (suffix in suffixes) {\r\n        val name = if (ext.isNotEmpty()) \"$baseName$suffix.$ext\" else \"$baseName$suffix\"\r\n        deleteAllMediaStoreDownloadsByName(context, name)\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download/$filename\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                onProgress(null)\r\n                Toast.makeText(context, \"‚ùå Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful || response.body == null) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    onProgress(null)\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onComplete()\r\n                }\r\n                return\r\n            }\r\n            try {\r\n                val body = response.body!!\r\n                val progressBody = ProgressResponseBody(body) { progress ->\r\n                    Handler(Looper.getMainLooper()).post { onProgress(progress) }\r\n                }\r\n                val contentLength = body.contentLength().takeIf { it > 0 }\r\n                val inputStream = progressBody.byteStream()\r\n\r\n\r\n                val mimeType = URLConnection.guessContentTypeFromName(filename)\r\n                    ?: \"application/octet-stream\"\r\n\r\n                fun createDecryptedStream(): InputStream {\r\n                    val b64Stream = Base64InputStream(inputStream, android.util.Base64.DEFAULT)\r\n                    val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n                    var read = 0\r\n                    while (read < header.size) {\r\n                        val r = b64Stream.read(header, read, header.size - read)\r\n                        if (r == -1) throw IOException(\"Unexpected EOF in header\")\r\n                        read += r\r\n                    }\r\n                    val salt = header.copyOfRange(0, SALT_SIZE)\r\n                    val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n                    val key = deriveKey(password, salt)\r\n                    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n                    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n                    return CipherInputStream(b64Stream, cipher)\r\n                }\r\n\r\n                val (savedPath, actualName) = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    saveToDownloadsQAndAboveUnique(context, filename, mimeType, ::createDecryptedStream, -1)\r\n                } else {\r\n                    saveToDownloadsLegacyUnique(context, filename, createDecryptedStream())\r\n                }\r\n                Handler(Looper.getMainLooper()).post {\r\n                    onProgress(null) // Reset after done\r\n                    if (savedPath != null) {\r\n                        Toast.makeText(context, \"‚úÖ Downloaded: $actualName\", Toast.LENGTH_LONG).show()\r\n                        Log.d(\"ClipboardSync\", \"Download handler completed for $filename, savedPath=$savedPath, actualName=$actualName\")\r\n                        showDownloadNotification(context, savedPath, actualName ?: filename, mimeType)\r\n                    } else {\r\n                        Toast.makeText(context, \"‚ùå Failed to save file\", Toast.LENGTH_LONG).show()\r\n                    }\r\n                    onComplete()\r\n                }\r\n            } catch (e: Exception) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    onProgress(null)\r\n                    Toast.makeText(context, \"‚ùå File decryption failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                    onComplete()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun getUniqueFilename(context: Context, filename: String, isLegacy: Boolean): String {\r\n    val (base, ext) = run {\r\n        val dot = filename.lastIndexOf('.')\r\n        if (dot in 1 until filename.length - 1)\r\n            filename.substring(0, dot) to filename.substring(dot)\r\n        else filename to \"\"\r\n    }\r\n    fun fileExists(name: String): Boolean {\r\n        return if (isLegacy) {\r\n            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n            File(downloadsDir, name).exists()\r\n        } else {\r\n            val resolver = context.contentResolver\r\n            val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n            val cursor = resolver.query(\r\n                collection,\r\n                arrayOf(MediaStore.Downloads.DISPLAY_NAME),\r\n                \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n                arrayOf(name),\r\n                null\r\n            )\r\n            val exists = cursor?.moveToFirst() == true\r\n            cursor?.close()\r\n            exists\r\n        }\r\n    }\r\n    if (!fileExists(filename)) return filename\r\n    var n = 1\r\n    while (true) {\r\n        val candidate = \"$base ($n)$ext\"\r\n        if (!fileExists(candidate)) return candidate\r\n        n++\r\n    }\r\n}\r\nfun deleteAllMediaStoreDownloadsByName(context: Context, fileName: String) {\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n        val resolver = context.contentResolver\r\n        val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n        val cursor = resolver.query(\r\n            collection,\r\n            arrayOf(MediaStore.Downloads._ID),\r\n            \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n            arrayOf(fileName),\r\n            null\r\n        )\r\n        cursor?.use {\r\n            val idCol = cursor.getColumnIndexOrThrow(MediaStore.Downloads._ID)\r\n            while (cursor.moveToNext()) {\r\n                val id = cursor.getLong(idCol)\r\n                val uri = ContentUris.withAppendedId(collection, id)\r\n                resolver.delete(uri, null, null)\r\n            }\r\n        }\r\n    }\r\n}\r\nfun saveToDownloadsQAndAboveUnique(\r\n    context: Context,\r\n    filename: String,\r\n    mimeType: String,\r\n    inputStreamFn: () -> InputStream,\r\n    size: Long\r\n): Pair<String?, String?> {\r\n    val resolver = context.contentResolver\r\n    val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n    val base = filename.substringBeforeLast('.')\r\n    val ext = filename.substringAfterLast('.', \"\")\r\n    var n = 0\r\n    var uniqueName = filename\r\n    var attempt = 0\r\n    var fileUri: Uri? = null\r\n    var outputWritten = false\r\n\r\n    while (attempt < 10) {\r\n        Log.d(\"ClipboardSync\", \"Attempt $attempt: Trying to save as $uniqueName\")\r\n        val values = ContentValues().apply {\r\n            put(MediaStore.Downloads.DISPLAY_NAME, uniqueName)\r\n            put(MediaStore.Downloads.MIME_TYPE, mimeType)\r\n            put(MediaStore.Downloads.IS_PENDING, 1)\r\n            if (size > 0) put(MediaStore.Downloads.SIZE, size)\r\n        }\r\n        fileUri = resolver.insert(collection, values)\r\n        if (fileUri != null) {\r\n            try {\r\n                inputStreamFn().use { input ->\r\n                    resolver.openOutputStream(fileUri)?.use { output ->\r\n                        val buffer = ByteArray(8192)\r\n                        var totalRead = 0L\r\n                        var read: Int\r\n                        while (input.read(buffer).also { read = it } != -1) {\r\n                            output.write(buffer, 0, read)\r\n                            totalRead += read\r\n                            // If your input is a ProgressInputStream, it will already call onProgress.\r\n                        }\r\n                    } ?: throw IOException(\"Output stream null\")\r\n                }\r\n                outputWritten = true\r\n                Log.d(\"ClipboardSync\", \"SUCCESS: File written as $uniqueName\")\r\n                values.clear()\r\n                values.put(MediaStore.Downloads.IS_PENDING, 0)\r\n                resolver.update(fileUri, values, null, null)\r\n                break\r\n            } catch (e: Exception) {\r\n                Log.e(\"ClipboardSync\", \"EXCEPTION: ${e.message}\")\r\n                // Always try to delete the just-created file from MediaStore\r\n                try { resolver.delete(fileUri, null, null) } catch (_: Exception) {}\r\n\r\n                // Try to delete the physical file at the content Uri (best effort)\r\n                try {\r\n                    resolver.openFileDescriptor(fileUri!!, \"w\")?.use {\r\n                        FileOutputStream(it.fileDescriptor).channel.truncate(0)\r\n                    }\r\n                    Log.d(\"ClipboardSync\", \"Truncated file at $fileUri after update failure\")\r\n                } catch (_: Exception) {}\r\n\r\n                if (e.message?.contains(\"UNIQUE constraint failed\") == true) {\r\n                    attempt++\r\n                    n++\r\n                    uniqueName = if (ext.isNotEmpty()) \"$base ($n).$ext\" else \"$base ($n)\"\r\n                    continue\r\n                } else {\r\n                    e.printStackTrace()\r\n                    break\r\n                }\r\n            }\r\n        } else {\r\n            attempt++\r\n            n++\r\n            uniqueName = if (ext.isNotEmpty()) \"$base ($n).$ext\" else \"$base ($n)\"\r\n        }\r\n    }\r\n    Log.d(\"ClipboardSync\", \"Returning from saveToDownloadsQAndAboveUnique: outputWritten=$outputWritten, fileUri=$fileUri, uniqueName=$uniqueName\")\r\n    return if (outputWritten && fileUri != null) {\r\n        Pair(fileUri.toString(), uniqueName)\r\n    } else {\r\n        Pair(null, null)\r\n    }\r\n}\r\n\r\nfun saveToDownloadsLegacyUnique(\r\n    context: Context,\r\n    filename: String,\r\n    inputStream: InputStream\r\n): Pair<String?, String?> {\r\n    val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n    if (!downloadsDir.exists()) downloadsDir.mkdirs()\r\n    val uniqueName = getUniqueFilename(context, filename, isLegacy = true)\r\n    val outFile = File(downloadsDir, uniqueName)\r\n    return try {\r\n        inputStream.use { input ->\r\n            outFile.outputStream().use { output ->\r\n                val buffer = ByteArray(8192)\r\n                var len: Int\r\n                while (input.read(buffer).also { len = it } != -1) {\r\n                    output.write(buffer, 0, len)\r\n                }\r\n            }\r\n        }\r\n        Pair(outFile.absolutePath, uniqueName)\r\n    } catch (e: Exception) {\r\n        e.printStackTrace()\r\n        Pair(null, null)\r\n    }\r\n}\r\n\r\nfun sendToServer(context: Context, text: String, ip: String, password: String, onStatusChange: (Boolean) -> Unit = {})\r\n {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onStatusChange(false)\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n     val encryptedText = encryptAESCBC(text, password)\r\n     val requestBody = FormBody.Builder().add(\"clipboard\", encryptedText).build()\r\n\r\n     val request = Request.Builder()\r\n        .url(\"http://$ip:8000/clipboard\")\r\n        .post(requestBody)\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                onStatusChange(false) // Notify failure\r\n                Toast.makeText(context, \"‚ùå Failed to sync: ${e.localizedMessage}\", Toast.LENGTH_LONG).show()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                val isSuccess = response.isSuccessful\r\n                onStatusChange(isSuccess)  // Pass status as Boolean\r\n\r\n                if (isSuccess) {\r\n                    Toast.makeText(context, \"‚úÖ Clipboard synced\", Toast.LENGTH_SHORT).show()\r\n                } else {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun fetchClipboardFromServer(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    clipboardManager: ClipboardManager,\r\n    addToHistory: (String) -> Unit,\r\n    onComplete: () -> Unit,\r\n    onProgress: (Float?) -> Unit = {} // <-- Add this parameter\r\n) {\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/clipboard\")\r\n        .get()\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    val client = OkHttpClient()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Fetch failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            response.use {\r\n                if (!it.isSuccessful) {\r\n                    Handler(Looper.getMainLooper()).post {\r\n                        Toast.makeText(context, \"‚ö†Ô∏è Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                        onComplete()\r\n                    }\r\n                    return\r\n                }\r\n\r\n                val bodyString = it.body?.string()\r\n                val json = JSONObject(bodyString)\r\n                val isFile = json.optBoolean(\"is_file\", false)\r\n\r\n                if (isFile) {\r\n                    val filename = json.optString(\"filename\", \"fetched_file\")\r\n                    downloadFileFromClipboard(\r\n                        context,\r\n                        ip,\r\n                        password,\r\n                        filename,\r\n                        onComplete = onComplete,\r\n                        onProgress = onProgress // <-- Pass it here\r\n                    )\r\n                } else {\r\n                    val encryptedText = json.getString(\"clipboard\")\r\n                    val text = decryptAESCBC(encryptedText, password)\r\n                    Handler(Looper.getMainLooper()).post {\r\n                        clipboardManager.setPrimaryClip(ClipData.newPlainText(\"label\", text))\r\n                        addToHistory(text)\r\n                        Toast.makeText(context, \"üìã Clipboard updated\", Toast.LENGTH_SHORT).show()\r\n                        onComplete()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\nfun downloadFileFromClipboard(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    filename: String,\r\n    onComplete: () -> Unit,\r\n    onProgress: (Float?) -> Unit = {}\r\n) {\r\n    Log.d(\"ClipboardSync\", \"downloadFileFromClipboard CALLED for $filename\")\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n        val baseName = filename.substringBeforeLast('.')\r\n        val ext = filename.substringAfterLast('.', \"\")\r\n        val suffixes = listOf(\"\") + (1..9).map { \" ($it)\" }\r\n        for (suffix in suffixes) {\r\n            val name = if (ext.isNotEmpty()) \"$baseName$suffix.$ext\" else \"$baseName$suffix\"\r\n            deleteAllMediaStoreDownloadsByName(context, name)\r\n        }\r\n    }\r\n\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download_clipboard_file\")\r\n        .get()\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n    val client = OkHttpClient()\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                onProgress(null)\r\n                Toast.makeText(context, \"‚ùå Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful || response.body == null) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    onProgress(null)\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onComplete()\r\n                }\r\n                return\r\n            }\r\n            try {\r\n                val body = response.body!!\r\n                val progressBody = ProgressResponseBody(body) { progress ->\r\n                    Handler(Looper.getMainLooper()).post { onProgress(progress) }\r\n                }\r\n                val contentLength = body.contentLength().takeIf { it > 0 }\r\n                val inputStream = progressBody.byteStream()\r\n\r\n                val mimeType = URLConnection.guessContentTypeFromName(filename) ?: \"application/octet-stream\"\r\n\r\n                fun createDecryptedStream(): InputStream {\r\n                    val b64Stream = Base64InputStream(inputStream, android.util.Base64.DEFAULT)\r\n                    val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n                    var read = 0\r\n                    while (read < header.size) {\r\n                        val r = b64Stream.read(header, read, header.size - read)\r\n                        if (r == -1) throw IOException(\"Unexpected EOF in header\")\r\n                        read += r\r\n                    }\r\n                    val salt = header.copyOfRange(0, SALT_SIZE)\r\n                    val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n                    val key = deriveKey(password, salt)\r\n                    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n                    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n                    return CipherInputStream(b64Stream, cipher)\r\n                }\r\n\r\n                val (savedPath, actualName) = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    saveToDownloadsQAndAboveUnique(context, filename, mimeType, ::createDecryptedStream, -1)\r\n                } else {\r\n                    saveToDownloadsLegacyUnique(context, filename, createDecryptedStream())\r\n                }\r\n                Handler(Looper.getMainLooper()).post {\r\n                    onProgress(null)\r\n                    if (savedPath != null) {\r\n                        Toast.makeText(context, \"‚úÖ Downloaded: $actualName\", Toast.LENGTH_LONG).show()\r\n                        Log.d(\"ClipboardSync\", \"Download handler completed for $filename, savedPath=$savedPath, actualName=$actualName\")\r\n                        showDownloadNotification(context, savedPath, actualName ?: filename, mimeType)\r\n                    } else {\r\n                        Toast.makeText(context, \"‚ùå Failed to save file\", Toast.LENGTH_LONG).show()\r\n                    }\r\n                    onComplete()\r\n                }\r\n            } catch (e: Exception) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    onProgress(null)\r\n                    Toast.makeText(context, \"‚ùå File decryption failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                    onComplete()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nclass MainActivity : ComponentActivity() {\r\n    // In MainActivity:\r\n    private lateinit var requestNotificationPermissionLauncher: ActivityResultLauncher<String>\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        requestNotificationPermissionLauncher = registerForActivityResult(\r\n            ActivityResultContracts.RequestPermission()\r\n        ) { isGranted: Boolean ->\r\n            // You can show a toast here or log if you want\r\n        }\r\n\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\r\n            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS)\r\n                != PackageManager.PERMISSION_GRANTED\r\n            ) {\r\n                requestNotificationPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)\r\n            }\r\n        }\r\n\r\n        setContent { ClipboardSyncApp() }\r\n        checkOverlayPermission()\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        val prefs = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n\r\n        if (intent.getBooleanExtra(\"syncNow\", false)) {\r\n            Handler(Looper.getMainLooper()).postDelayed({\r\n                syncClipboardFromActivity()\r\n                intent.removeExtra(\"syncNow\")\r\n                moveTaskToBack(true)\r\n            }, 50)\r\n        }\r\n\r\n        if (intent.getBooleanExtra(\"fetchNow\", false)) {\r\n            Handler(Looper.getMainLooper()).postDelayed({\r\n                val clipboardManager = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n                val password = prefs.getString(\"server_password\", \"\") ?: \"\"\r\n                fetchClipboardFromServer(\r\n                    context = this,\r\n                    ip = prefs.getString(\"server_ip\", \"\") ?: \"\",\r\n                    password = password,\r\n                    clipboardManager = clipboardManager,\r\n                    addToHistory = { _ -> },\r\n                    onComplete = { /* Optionally show a notification here if desired */ },\r\n                    onProgress = {}\r\n                )\r\n                // Minimize the app right after starting fetch (don't wait for onComplete)\r\n                moveTaskToBack(true)\r\n                intent.removeExtra(\"fetchNow\")\r\n            }, 50)\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private fun syncClipboardFromActivity() {\r\n        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n        val clip = clipboard.primaryClip\r\n        val text = clip?.getItemAt(0)?.text?.toString()\r\n        val prefs = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n        val ip = prefs.getString(\"server_ip\", \"\") ?: \"\"\r\n\r\n        if (!text.isNullOrEmpty()) {\r\n            val password = prefs.getString(\"server_password\", \"\") ?: \"\"\r\n            sendToServer(this, text, ip, password)\r\n        } else {\r\n            Toast.makeText(this, \"\\uD83D\\uDCCB Clipboard is empty\", Toast.LENGTH_SHORT).show()\r\n        }\r\n\r\n        Handler(Looper.getMainLooper()).postDelayed({\r\n            moveTaskToBack(true)\r\n        }, 1000)\r\n    }\r\n\r\n    private fun checkOverlayPermission() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            if (!Settings.canDrawOverlays(this)) {\r\n                val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:$packageName\"))\r\n                startActivity(intent)\r\n            } else {\r\n                startOverlayService()\r\n            }\r\n        } else {\r\n            startOverlayService()\r\n        }\r\n    }\r\n\r\n    private fun startOverlayService() {\r\n        val intent = Intent(this, OverlayService::class.java)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent)\r\n        else startService(intent)\r\n\r\n        Toast.makeText(this, \"\\u2705 Overlay service started\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n\r\n",
  "import threading\r\nimport socket\r\nimport pyperclip\r\nimport os\r\nimport subprocess\r\nimport sys\r\nimport time\r\nimport json\r\nimport win32clipboard\r\nfrom fastapi import FastAPI, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\nimport uvicorn\r\nfrom pystray import Icon, MenuItem, Menu\r\nfrom PIL import Image, ImageDraw\r\nfrom zeroconf import Zeroconf, ServiceInfo\r\nimport tkinter as tk\r\nfrom tkinter import ttk\r\nfrom pathlib import Path\r\nfrom fastapi import FastAPI, Request, HTTPException\r\nfrom fastapi.responses import JSONResponse\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\nfrom fastapi import UploadFile, File\r\nfrom fastapi import FastAPI, File, UploadFile, HTTPException, Header\r\nimport re\r\nimport ctypes\r\nimport win32con\r\nimport win32gui\r\nimport win32process\r\nimport win32clipboard\r\nfrom fastapi.responses import FileResponse\r\nimport Crypto\r\nfrom Crypto.Cipher import AES\r\nfrom hashlib import sha256\r\nimport base64\r\nimport os\r\nimport base64\r\nfrom hashlib import sha256\r\nfrom Crypto.Hash import SHA256\r\nfrom Crypto.Cipher import AES\r\nfrom Crypto.Protocol.KDF import PBKDF2\r\nfrom Crypto.Random import get_random_bytes\r\nfrom fastapi.responses import Response\r\n\r\n# === Globals ===\r\nPBKDF2_ITER = 10000\r\nKEY_LEN = 32  # 256 bits\r\nSALT_SIZE = 16\r\nIV_SIZE = 16\r\nPASSWORD = \"your_secure_password\"\r\nUPLOAD_DIR = Path(\"received_files\")\r\nUPLOAD_DIR.mkdir(exist_ok=True)\r\nzeroconf = Zeroconf()\r\ninfo = None\r\ntray_icon = None\r\nip_address = None\r\ntray_icon_active = False\r\nlast_ip = None\r\nip_changed = False\r\nmonitor_thread = None\r\nstop_monitoring = False\r\nis_restarting = False\r\nrestart_cooldown = 5\r\nconnected_clients = set()\r\nclipboard_history = []\r\nHISTORY_LIMIT = 20\r\nHISTORY_FILE = Path(\"clipboard_history.txt\")\r\ntk_window = None\r\nroot = None  # Tkinter root\r\nCONFIG_FILE = \"config.json\"\r\n\r\n# === FastAPI server ===\r\napp = FastAPI()\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=[\"*\"],\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# === Helper functions ===\r\ndef load_config():\r\n    global PASSWORD\r\n    try:\r\n        if Path(CONFIG_FILE).exists():\r\n            with open(CONFIG_FILE, \"r\", encoding=\"utf-8\") as f:\r\n                config = json.load(f)\r\n                PASSWORD = config.get(\"password\", PASSWORD)\r\n                print(\"üîê Loaded password from config.\")\r\n    except Exception as e:\r\n        print(f\"‚ö†Ô∏è Failed to load config: {e}\")\r\n\r\ndef save_config():\r\n    try:\r\n        with open(CONFIG_FILE, \"w\", encoding=\"utf-8\") as f:\r\n            json.dump({\"password\": PASSWORD}, f, indent=2)\r\n            print(\"‚úÖ Password saved to config.\")\r\n    except Exception as e:\r\n        print(f\"‚ö†Ô∏è Failed to save config: {e}\")\r\n\r\ndef sanitize_filename(filename: str) -> str:\r\n    # Remove characters invalid on Windows: \\ / : * ? \" < > |\r\n    return re.sub(r'[\\\\/*?:\"<>|]', \"_\", filename)\r\n\r\ndef load_history_from_file():\r\n    global clipboard_history\r\n    if HISTORY_FILE.exists():\r\n        try:\r\n            with open(HISTORY_FILE, \"r\", encoding=\"utf-8\") as f:\r\n                clipboard_history = json.load(f)\r\n                clipboard_history = clipboard_history[:HISTORY_LIMIT]\r\n        except Exception as e:\r\n            print(f\"‚ö†Ô∏è Error loading history file: {e}\")\r\n            clipboard_history = []\r\n\r\n\r\ndef save_history_to_file():\r\n    with open(HISTORY_FILE, \"w\", encoding=\"utf-8\") as f:\r\n        for entry in clipboard_history[:HISTORY_LIMIT]:\r\n            f.write(entry + \"\\n\")\r\n\r\ndef save_history_to_file():\r\n    with open(HISTORY_FILE, \"w\", encoding=\"utf-8\") as f:\r\n        json.dump(clipboard_history[:HISTORY_LIMIT], f, ensure_ascii=False, indent=2)\r\n\r\ndef add_to_history(text):\r\n    global clipboard_history\r\n    if text.strip() and (not clipboard_history or clipboard_history[0] != text):\r\n        if text in clipboard_history:\r\n            clipboard_history.remove(text)\r\n        clipboard_history.insert(0, text)\r\n        if len(clipboard_history) > HISTORY_LIMIT:\r\n            clipboard_history.pop()\r\n        save_history_to_file()\r\n\r\ndef start_server():\r\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\r\n\r\ndef get_ip():\r\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\n    try:\r\n        s.connect((\"8.8.8.8\", 80))\r\n        ip = s.getsockname()[0]\r\n    except Exception:\r\n        ip = \"127.0.0.1\"\r\n    finally:\r\n        s.close()\r\n    return ip\r\n\r\ndef register_service():\r\n    global info\r\n    ip = get_ip()\r\n    desc = {\"info\": \"Clipboard Sync Server\"}\r\n    info = ServiceInfo(\r\n        \"_http._tcp.local.\",\r\n        \"ClipboardSyncServer._http._tcp.local.\",\r\n        addresses=[socket.inet_aton(ip)],\r\n        port=8000,\r\n        properties=desc,\r\n        server=f\"{socket.gethostname()}.local.\"\r\n    )\r\n    zeroconf.register_service(info)\r\n    print(f\"üì£ Zeroconf service registered: {ip}:8000\")\r\n    return ip\r\n\r\ndef unregister_service():\r\n    global info\r\n    if info:\r\n        try:\r\n            zeroconf.unregister_service(info)\r\n            print(\"üõë Zeroconf service unregistered.\")\r\n        except Exception as e:\r\n            print(f\"‚ö†Ô∏è Error unregistering service: {e}\")\r\n        info = None\r\n\r\ndef create_icon():\r\n    icon_image = Image.new(\"RGBA\", (64, 64), (255, 255, 255, 0))\r\n    draw = ImageDraw.Draw(icon_image)\r\n    draw.rectangle((0, 0, 64, 64), fill=(0, 0, 255))\r\n    draw.text((18, 20), \"CB\", fill=\"white\")\r\n    return icon_image\r\n\r\ndef on_quit(icon, item):\r\n    unregister_service()\r\n    icon.stop()\r\n    if root:\r\n        root.quit()\r\n\r\ndef on_restart(icon, item):\r\n    unregister_service()\r\n    icon.stop()\r\n    if root:\r\n        root.quit()\r\n    print(\"üîÑ Restarting app...\")\r\n    os.execl(sys.executable, sys.executable, *sys.argv)\r\n\r\ndef show_connections(icon, item):\r\n    def show_window():\r\n        global tk_window\r\n        if tk_window and tk_window.winfo_exists():\r\n            tk_window.lift()\r\n            return\r\n\r\n        tk_window = tk.Toplevel(root)\r\n        tk_window.title(\"Connected Devices\")\r\n        tk_window.geometry(\"300x200\")\r\n\r\n        ttk.Label(tk_window, text=\"Connected IPs:\", font=(\"Segoe UI\", 12)).pack(pady=10)\r\n        box = tk.Listbox(tk_window, font=(\"Segoe UI\", 10))\r\n        box.pack(expand=True, fill=\"both\", padx=10)\r\n\r\n        for ip in sorted(connected_clients):\r\n            box.insert(tk.END, ip)\r\n\r\n        ttk.Button(tk_window, text=\"Close\", command=tk_window.destroy).pack(pady=5)\r\n\r\n    root.after(0, show_window)\r\n\r\ndef show_clipboard_history(icon, item):\r\n    def show_window():\r\n        global tk_window\r\n        if tk_window and tk_window.winfo_exists():\r\n            tk_window.lift()\r\n            return\r\n\r\n        tk_window = tk.Toplevel(root)\r\n        tk_window.title(\"Clipboard History\")\r\n        tk_window.geometry(\"400x300\")\r\n\r\n        ttk.Label(tk_window, text=\"Clipboard History:\", font=(\"Segoe UI\", 12)).pack(pady=10)\r\n        box = tk.Listbox(tk_window, font=(\"Segoe UI\", 10), selectmode=tk.SINGLE)\r\n        box.pack(expand=True, fill=\"both\", padx=10)\r\n\r\n        entry_map = []\r\n\r\n        for entry in clipboard_history:\r\n            display = entry.replace(\"\\n\", \"‚èé\")\r\n            short = display if len(display) <= 100 else display[:100] + \"...\"\r\n            box.insert(tk.END, short)\r\n            entry_map.append(entry)\r\n\r\n        # === Tooltip widget ===\r\n        tooltip = tk.Toplevel(tk_window)\r\n        tooltip.withdraw()\r\n        tooltip.overrideredirect(True)\r\n        label = tk.Label(tooltip, text=\"\", justify=\"left\", bg=\"#ffffe0\", relief=\"solid\", borderwidth=1,\r\n                         font=(\"Segoe UI\", 9), wraplength=350)\r\n        label.pack()\r\n\r\n        def show_tooltip(event):\r\n            try:\r\n                index = box.nearest(event.y)\r\n                full_text = entry_map[index]\r\n                label.config(text=full_text)\r\n                x = event.x_root + 10\r\n                y = event.y_root + 10\r\n                tooltip.geometry(f\"+{x}+{y}\")\r\n                tooltip.deiconify()\r\n            except Exception:\r\n                tooltip.withdraw()\r\n\r\n        def hide_tooltip(event):\r\n            tooltip.withdraw()\r\n\r\n        box.bind(\"<Motion>\", show_tooltip)\r\n        box.bind(\"<Leave>\", hide_tooltip)\r\n\r\n        def on_copy_selected():\r\n            selected = box.curselection()\r\n            if selected:\r\n                full_text = entry_map[selected[0]]\r\n                pyperclip.copy(full_text)\r\n                print(\"‚úÖ Copied to clipboard:\", repr(full_text))\r\n\r\n        def on_double_click(event):\r\n            on_copy_selected()\r\n\r\n        box.bind(\"<Double-Button-1>\", on_double_click)\r\n\r\n        def on_clear_history():\r\n            global clipboard_history\r\n            clipboard_history.clear()\r\n            save_history_to_file()\r\n            box.delete(0, tk.END)\r\n            entry_map.clear()\r\n            print(\"üßπ Clipboard history cleared.\")\r\n\r\n        ttk.Button(tk_window, text=\"Copy Selected\", command=on_copy_selected).pack(pady=5)\r\n        ttk.Button(tk_window, text=\"Clear History\", command=on_clear_history).pack(pady=5)\r\n        ttk.Button(tk_window, text=\"Close\", command=tk_window.destroy).pack(pady=5)\r\n\r\n    root.after(0, show_window)\r\n\r\ndef create_tray_menu(ip=None):\r\n    ip = ip or get_ip()\r\n    return Menu(\r\n        MenuItem(\"Open Received Files\", open_received_files_folder),\r\n        MenuItem(\"Clipboard History\", show_clipboard_history),\r\n        MenuItem(\"Set Password\", show_set_password_window),\r\n        MenuItem(\"Restart\", on_restart),\r\n        MenuItem(\"Quit\", on_quit),\r\n        MenuItem(f\"IP Address: {ip}\", lambda *_: None, enabled=False)\r\n    )\r\n\r\ndef safe_restart():\r\n    try:\r\n        subprocess.Popen([sys.executable] + sys.argv)\r\n        sys.exit(0)\r\n    except Exception as e:\r\n        print(\"‚ùå Restart failed:\", e)\r\n\r\n\r\ndef restart_app():\r\n    global is_restarting, tray_icon_active\r\n    if not is_restarting:\r\n        is_restarting = True\r\n        print(\"üåê IP changed, restarting the app...\")\r\n        if tray_icon_active:\r\n            tray_icon.stop()\r\n            tray_icon_active = False\r\n        unregister_service()\r\n        time.sleep(restart_cooldown)\r\n        safe_restart()\r\n    else:\r\n        print(\"üõë App is already restarting. Ignoring IP change.\")\r\n\r\ndef monitor_ip_change():\r\n    global ip_address, last_ip, ip_changed, stop_monitoring, is_restarting\r\n    debounce_time = 3\r\n    ip_initialized = False\r\n\r\n    while True:\r\n        if stop_monitoring:\r\n            print(\"üõë Stopping IP monitoring thread...\")\r\n            break\r\n        time.sleep(1)\r\n        current_ip = get_ip()\r\n        if not ip_initialized and current_ip != \"127.0.0.1\":\r\n            ip_initialized = True\r\n            last_ip = current_ip\r\n            print(f\"üåê Initial IP detected: {current_ip}. No restart triggered yet.\")\r\n            continue\r\n        if current_ip != last_ip and not is_restarting:\r\n            ip_changed = True\r\n            print(f\"üåê IP changed from {last_ip} ‚û° {current_ip}. Restarting app...\")\r\n            last_ip = current_ip\r\n            restart_app()\r\n        elif current_ip == last_ip:\r\n            ip_changed = False\r\n        time.sleep(debounce_time)\r\n\r\ndef check_password(request: Request):\r\n    token = request.headers.get(\"X-Auth-Token\")\r\n    if token != PASSWORD:\r\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\r\n\r\n@app.get(\"/ping\")\r\nasync def ping(request: Request):\r\n    check_password(request)\r\n    return {\"status\": \"ok\"}\r\n\r\ndef get_clipboard_file_path():\r\n    try:\r\n        win32clipboard.OpenClipboard()\r\n        CF_HDROP = 15\r\n        if win32clipboard.IsClipboardFormatAvailable(CF_HDROP):\r\n            files = win32clipboard.GetClipboardData(CF_HDROP)\r\n            return files[0] if files else None\r\n    except Exception as e:\r\n        print(\"Clipboard file check failed:\", e)\r\n    finally:\r\n        try:\r\n            win32clipboard.CloseClipboard()\r\n        except:\r\n            pass\r\n    return None\r\n\r\n@app.get(\"/clipboard\")\r\nasync def get_clipboard(request: Request):\r\n    check_password(request)\r\n    clipboard_file = get_clipboard_file_path()\r\n    if clipboard_file and os.path.isfile(clipboard_file):\r\n        return {\r\n            \"status\": \"sent\",\r\n            \"clipboard\": encrypt_text(clipboard_file, PASSWORD),\r\n            \"is_file\": True,\r\n            \"filename\": os.path.basename(clipboard_file)\r\n        }\r\n    clipboard_text = pyperclip.paste()\r\n    return {\r\n        \"status\": \"sent\",\r\n        \"clipboard\": encrypt_text(clipboard_text, PASSWORD),\r\n        \"is_file\": False\r\n    }\r\n\r\n@app.post(\"/clipboard\")\r\nasync def set_clipboard(request: Request):\r\n    check_password(request)\r\n    form = await request.form()\r\n    encrypted_clipboard = form.get(\"clipboard\", \"\")\r\n    clipboard = decrypt_text(encrypted_clipboard, PASSWORD)\r\n    pyperclip.copy(clipboard)\r\n    if clipboard.strip():\r\n        add_to_history(clipboard)\r\n    return {\"status\": \"received\", \"clipboard\": clipboard}\r\n\r\n@app.post(\"/upload\")\r\nasync def upload_file(file: UploadFile = File(...), x_auth_token: str = Header(None)):\r\n    if x_auth_token != PASSWORD:\r\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\r\n    save_path = Path(\"received_files\")\r\n    save_path.mkdir(parents=True, exist_ok=True)\r\n    safe_filename = sanitize_filename(file.filename or \"uploaded_file\")\r\n    file_path = save_path / safe_filename\r\n    content = await file.read()\r\n    decrypted_content = decrypt_file_bytes(content, PASSWORD)\r\n    print(f\"üìÅ Saving file: {file_path}\")\r\n    print(f\"üì¶ Received size: {len(content)} bytes\")\r\n    with open(file_path, \"wb\") as f:\r\n        f.write(decrypted_content)\r\n    return {\"status\": \"success\", \"filename\": safe_filename}\r\n\r\n@app.get(\"/list-files\")\r\ndef list_files(x_auth_token: str = Header(None)):\r\n    if x_auth_token != PASSWORD:\r\n        raise HTTPException(status_code=401, detail=\"Invalid password\")\r\n\r\n    if not os.path.isdir(UPLOAD_DIR):\r\n        return JSONResponse(content={\"files\": []})\r\n\r\n    files = os.listdir(UPLOAD_DIR)\r\n    return {\"files\": files}\r\n\r\n@app.get(\"/download_clipboard_file\")\r\ndef download_clipboard_file(x_auth_token: str = Header(None)):\r\n    if x_auth_token != PASSWORD:\r\n        raise HTTPException(status_code=401, detail=\"Invalid password\")\r\n    clipboard = get_clipboard_file_path()\r\n    print(f\"üìã File path from clipboard: {clipboard}\")\r\n    print(f\"üìã Clipboard content: {clipboard}\")\r\n    if not os.path.isfile(clipboard):\r\n        print(\"‚ùå Clipboard does not contain a valid file path\")\r\n        raise HTTPException(status_code=404, detail=\"Clipboard does not contain a valid file\")\r\n    try:\r\n        with open(clipboard, \"rb\") as f:\r\n            raw = f.read()\r\n        encrypted = encrypt_file_bytes(raw, PASSWORD)\r\n        encoded = base64.b64encode(encrypted)\r\n        return Response(content=encoded, media_type=\"application/octet-stream\")\r\n    except Exception as e:\r\n        print(f\"‚ùå Error serving clipboard file: {e}\")\r\n        raise HTTPException(status_code=500, detail=\"Failed to send file\")\r\n\r\n\r\n@app.get(\"/download/{filename}\")\r\ndef download_file(filename: str, x_auth_token: str = Header(None)):\r\n    if x_auth_token != PASSWORD:\r\n        raise HTTPException(status_code=401, detail=\"Invalid password\")\r\n    file_path = os.path.join(UPLOAD_DIR, filename)\r\n    if not os.path.isfile(file_path):\r\n        raise HTTPException(status_code=404, detail=\"File not found\")\r\n    with open(file_path, \"rb\") as f:\r\n        raw = f.read()\r\n    encrypted = encrypt_file_bytes(raw, PASSWORD)\r\n    encoded = base64.b64encode(encrypted)\r\n    return Response(content=encoded, media_type=\"application/octet-stream\")\r\n\r\n\r\ndef open_received_files_folder(icon, item):\r\n    folder_path = str(UPLOAD_DIR.resolve())\r\n    try:\r\n        os.startfile(folder_path)  # Windows-only\r\n        print(f\"üìÇ Opened folder: {folder_path}\")\r\n    except Exception as e:\r\n        print(f\"‚ö†Ô∏è Could not open folder: {e}\")\r\n\r\ndef minimize_console_window():\r\n    hwnd = ctypes.windll.kernel32.GetConsoleWindow()\r\n    if hwnd:\r\n        win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)\r\n\r\ndef show_set_password_window(icon=None, item=None):\r\n    def save_new_password():\r\n        global PASSWORD\r\n        new_pass = entry.get().strip()\r\n        if new_pass:\r\n            PASSWORD = new_pass\r\n            save_config()\r\n            print(\"üîê Password updated.\")\r\n            win.destroy()\r\n\r\n    def toggle_password_visibility():\r\n        if show_var.get():\r\n            entry.config(show=\"\")\r\n        else:\r\n            entry.config(show=\"*\")\r\n\r\n    global tk_window\r\n    if tk_window and tk_window.winfo_exists():\r\n        tk_window.lift()\r\n        return\r\n\r\n    win = tk.Toplevel(root)\r\n    win.title(\"Set Server Password\")\r\n    win.geometry(\"300x180\")\r\n    win.resizable(False, False)\r\n\r\n    ttk.Label(win, text=\"Enter new password:\", font=(\"Segoe UI\", 11)).pack(pady=(10, 5))\r\n    \r\n    entry = ttk.Entry(win, show=\"*\", font=(\"Segoe UI\", 11))\r\n    entry.pack(pady=5, padx=20, fill=\"x\")\r\n    entry.insert(0, PASSWORD)\r\n\r\n    show_var = tk.BooleanVar(value=False)\r\n    show_checkbox = ttk.Checkbutton(win, text=\"Show Password\", variable=show_var, command=toggle_password_visibility)\r\n    show_checkbox.pack(pady=(0, 10))\r\n\r\n    ttk.Button(win, text=\"Save\", command=save_new_password).pack(pady=10)\r\n\r\ndef pad_data(data: bytes) -> bytes:\r\n    pad_len = 16 - len(data) % 16\r\n    return data + bytes([pad_len] * pad_len)\r\n\r\ndef unpad_data(data: bytes) -> bytes:\r\n    pad_len = data[-1]\r\n    return data[:-pad_len]\r\n\r\ndef encrypt_file_bytes(data: bytes, password: str) -> bytes:\r\n    salt = get_random_bytes(SALT_SIZE)\r\n    iv = get_random_bytes(IV_SIZE)\r\n    key = derive_key(password.encode(), salt)\r\n    cipher = AES.new(key, AES.MODE_CBC, iv)\r\n    pad_len = 16 - len(data) % 16\r\n    padded = data + bytes([pad_len] * pad_len)\r\n    encrypted = cipher.encrypt(padded)\r\n    return salt + iv + encrypted\r\n\r\ndef decrypt_file_bytes(data: bytes, password: str) -> bytes:\r\n    salt = data[:SALT_SIZE]\r\n    iv = data[SALT_SIZE:SALT_SIZE+IV_SIZE]\r\n    ciphertext = data[SALT_SIZE+IV_SIZE:]\r\n    key = derive_key(password.encode(), salt)\r\n    cipher = AES.new(key, AES.MODE_CBC, iv)\r\n    decrypted = cipher.decrypt(ciphertext)\r\n    pad_len = decrypted[-1]\r\n    return decrypted[:-pad_len]\r\n\r\ndef derive_key(password: str, salt: bytes) -> bytes:\r\n    \"\"\"Derive a key from password and salt using PBKDF2 (HMAC-SHA256).\"\"\"\r\n    return PBKDF2(password, salt, dkLen=KEY_LEN, count=PBKDF2_ITER, hmac_hash_module=SHA256)\r\n\r\ndef get_aes_key(password: str) -> bytes:\r\n    return sha256(password.encode()).digest()\r\n\r\ndef encrypt_text(text: str, password: str) -> str:\r\n    salt = get_random_bytes(SALT_SIZE)\r\n    iv = get_random_bytes(IV_SIZE)\r\n    key = derive_key(password.encode(), salt)\r\n    cipher = AES.new(key, AES.MODE_CBC, iv)\r\n    data = text.encode(\"utf-8\")\r\n    pad_len = 16 - len(data) % 16\r\n    padded = data + bytes([pad_len] * pad_len)\r\n    encrypted = cipher.encrypt(padded)\r\n    out = salt + iv + encrypted\r\n    return base64.b64encode(out).decode(\"utf-8\")\r\n\r\ndef decrypt_text(encrypted_text: str, password: str) -> str:\r\n    raw = base64.b64decode(encrypted_text)\r\n    salt = raw[:SALT_SIZE]\r\n    iv = raw[SALT_SIZE:SALT_SIZE+IV_SIZE]\r\n    ciphertext = raw[SALT_SIZE+IV_SIZE:]\r\n    key = derive_key(password.encode(), salt)\r\n    cipher = AES.new(key, AES.MODE_CBC, iv)\r\n    decrypted = cipher.decrypt(ciphertext)\r\n    pad_len = decrypted[-1]\r\n    return decrypted[:-pad_len].decode(\"utf-8\")\r\n\r\n# === Main ===\r\nif __name__ == \"__main__\":\r\n    minimize_console_window()\r\n    load_history_from_file()  # Load history when app starts\r\n    load_config()\r\n    root = tk.Tk()\r\n    root.withdraw()  # Hide root window\r\n\r\n    # Start FastAPI server\r\n    threading.Thread(target=start_server, daemon=True).start()\r\n\r\n    # Register Zeroconf\r\n    ip_address = register_service()\r\n\r\n    # Monitor IP changes\r\n    monitor_thread = threading.Thread(target=monitor_ip_change, daemon=True)\r\n    monitor_thread.start()\r\n\r\n    # Create tray icon\r\n    tray_icon = Icon(\"ClipboardSync\", create_icon(), menu=create_tray_menu(ip_address))\r\n    tray_thread = threading.Thread(target=tray_icon.run, daemon=True)\r\n    tray_thread.start()\r\n    tray_icon_active = True\r\n\r\n    try:\r\n        root.mainloop()  # Run GUI event loop in main thread\r\n    except KeyboardInterrupt:\r\n        print(\"üî¥ Application terminated.\")\r\n",
  "https://github.com/copilot/c/4dd5d915-687b-481d-8b91-bb1f0d1dc825",
  "copilot",
  "C:\\Users\\Prasen\\AndroidStudioProjects\\ClipboardSync\\dist\\received_files",
  "modifier = Modifier.weight(1f),\r\n    shape = RoundedCornerShape(6.dp),",
  "And keep (or rename) t",
  "The missing progress bar",
  "hClipboardFromServ",
  "fetchClipboardFromServer",
  "fetch file",
  "Toast",
  "package com.example.clipboardsync\r\n\r\nimport android.content.*\r\nimport android.net.nsd.*\r\nimport android.os.*\r\nimport android.provider.Settings\r\nimport android.widget.Toast\r\nimport androidx.activity.ComponentActivity\r\nimport androidx.activity.compose.setContent\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.unit.sp\r\nimport okhttp3.*\r\nimport org.json.JSONArray\r\nimport org.json.JSONObject\r\nimport java.io.IOException\r\nimport androidx.compose.foundation.clickable\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.verticalScroll\r\nimport android.content.ClipData\r\nimport android.content.Context\r\nimport android.content.SharedPreferences\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.lazy.items\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport kotlinx.coroutines.*\r\nimport okhttp3.OkHttpClient\r\nimport okhttp3.Request\r\nimport java.util.concurrent.TimeUnit\r\nimport androidx.activity.compose.rememberLauncherForActivityResult\r\nimport androidx.activity.result.contract.ActivityResultContracts\r\nimport android.net.Uri\r\nimport android.os.Handler\r\nimport android.os.Looper\r\nimport java.io.File\r\nimport okhttp3.MediaType.Companion.toMediaTypeOrNull\r\nimport okhttp3.RequestBody.Companion.asRequestBody\r\nimport android.webkit.MimeTypeMap\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material3.ButtonDefaults\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.foundation.*\r\nimport androidx.compose.material3.TextFieldDefaults\r\nimport kotlinx.coroutines.delay\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Visibility\r\nimport androidx.compose.material.icons.filled.VisibilityOff\r\nimport androidx.compose.ui.text.input.PasswordVisualTransformation\r\nimport androidx.compose.ui.text.input.VisualTransformation\r\nimport android.content.ContentValues\r\nimport android.os.Build\r\nimport android.provider.MediaStore\r\nimport java.io.InputStream\r\nimport java.net.URLConnection\r\nimport android.os.Environment\r\nimport javax.crypto.Cipher\r\nimport javax.crypto.spec.SecretKeySpec\r\nimport java.security.MessageDigest\r\nimport android.util.Base64\r\nimport java.security.SecureRandom\r\nimport javax.crypto.SecretKeyFactory\r\nimport javax.crypto.spec.IvParameterSpec\r\nimport javax.crypto.spec.PBEKeySpec\r\nimport javax.crypto.CipherInputStream\r\nimport android.util.Base64InputStream\r\nimport androidx.core.app.NotificationCompat\r\nimport androidx.core.app.NotificationManagerCompat\r\nimport android.app.PendingIntent\r\nimport android.content.Intent\r\nimport androidx.core.content.FileProvider\r\nimport android.content.pm.PackageManager\r\nimport androidx.core.app.ActivityCompat\r\nimport android.app.NotificationChannel\r\nimport android.app.NotificationManager\r\n\r\n@Composable\r\nfun ClipboardSyncApp() {\r\n    val context = LocalContext.current\r\n    val clipboardManager = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n    val prefs = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n    var downloadingCount by remember { mutableStateOf(0) }\r\n    val isDownloading = downloadingCount > 0\r\n    var uploadingCount by remember { mutableStateOf(0) }\r\n    val isUploading = uploadingCount > 0\r\n    var showFileDialog by remember { mutableStateOf(false) }\r\n    var lastText by remember { mutableStateOf(\"\") }\r\n    var ipAddress by remember { mutableStateOf(prefs.getString(\"server_ip\", \"\") ?: \"\") }\r\n    var history by remember { mutableStateOf(loadHistory(prefs)) }\r\n    var isConnected by remember { mutableStateOf(false) }\r\n    var password by remember { mutableStateOf(prefs.getString(\"server_password\", \"\") ?: \"\") }\r\n    var availableFiles by remember { mutableStateOf<List<String>>(emptyList()) }\r\n    val ip = prefs.getString(\"server_ip\", \"\") ?: \"\"\r\n    var clipboardHistory by remember { mutableStateOf(listOf<String>()) }\r\n    val fileLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\r\n        uri?.let {\r\n            uploadFileToServer(context, it, ipAddress, password) { uploading ->\r\n                uploadingCount = when {\r\n                    uploading -> uploadingCount + 1\r\n                    uploadingCount > 0 -> uploadingCount - 1\r\n                    else -> 0\r\n                }\r\n            }\r\n        }\r\n    }\r\n    val buttonColor = Color(0xFF546E7A)\r\n    val buttonTextColor = Color.White\r\n\r\n    fun savePassword(pass: String) = prefs.edit().putString(\"server_password\", pass).apply()\r\n    fun saveIp(ip: String) = prefs.edit().putString(\"server_ip\", ip).apply()\r\n\r\n    fun addToHistory(text: String) {\r\n        val newHistory = listOf(text) + history.filterNot { it == text }\r\n        history = newHistory.take(50)\r\n        prefs.edit().putString(\"clipboard_history\", JSONArray(newHistory).toString()).apply()\r\n    }\r\n\r\n    fun deleteFromHistory(item: String) {\r\n        history = history.filterNot { it == item }\r\n        prefs.edit().putString(\"clipboard_history\", JSONArray(history).toString()).apply()\r\n    }\r\n\r\n    LaunchedEffect(ipAddress) {\r\n        while (true) {\r\n            pingServer(context, ipAddress, password) { isConnected = it }\r\n            delay(5000)\r\n        }\r\n    }\r\n\r\n    LaunchedEffect(Unit) {\r\n        discoverService(context) {\r\n            ipAddress = it\r\n            saveIp(it)\r\n        }\r\n        clipboardManager.primaryClip?.getItemAt(0)?.text?.toString()?.let {\r\n            if (it.isNotBlank()) {\r\n                lastText = it\r\n                addToHistory(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    DisposableEffect(Unit) {\r\n        val listener = ClipboardManager.OnPrimaryClipChangedListener {\r\n            val text = clipboardManager.primaryClip?.getItemAt(0)?.text.toString()\r\n            if (text.isNotBlank() && text != lastText) {\r\n                lastText = text\r\n                addToHistory(text)\r\n                sendToServer(context, text, ipAddress, password)\r\n            }\r\n        }\r\n        clipboardManager.addPrimaryClipChangedListener(listener)\r\n        onDispose { clipboardManager.removePrimaryClipChangedListener(listener) }\r\n    }\r\n\r\n    var selectedItem by remember { mutableStateOf<String?>(null) }\r\n    var passwordVisible by remember { mutableStateOf(false) }\r\n\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .background(Color(0xFF263238)) // dark blue-grey\r\n            .padding(16.dp),\r\n        verticalArrangement = Arrangement.spacedBy(16.dp)\r\n    ) {Card(\r\n        modifier = Modifier.fillMaxWidth(),\r\n        colors = CardDefaults.cardColors(containerColor = Color(0xFF37474F)),\r\n        shape = RoundedCornerShape(8.dp),\r\n        elevation = CardDefaults.cardElevation(4.dp)\r\n    ) {\r\n        Column(modifier = Modifier.padding(16.dp)) {\r\n\r\n            Row(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                horizontalArrangement = Arrangement.SpaceBetween,\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                Text(\r\n                    text = \"Connection Settings\",\r\n                    fontSize = 18.sp,\r\n                    color = Color.White\r\n                )\r\n\r\n                Text(\r\n                    text = if (isConnected) \"üü¢ Connected\" else \"üî¥ Disconnected\",\r\n                    color = if (isConnected) Color.Green else Color.Red,\r\n                    fontSize = 14.sp\r\n                )\r\n            }\r\n\r\n            Spacer(modifier = Modifier.height(12.dp))\r\n\r\n            Row(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                horizontalArrangement = Arrangement.spacedBy(8.dp),\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                TextField(\r\n                    value = ipAddress,\r\n                    onValueChange = {\r\n                        ipAddress = it\r\n                        saveIp(it)\r\n                    },\r\n                    label = { Text(\"Server IP Address\", color = Color.White) },\r\n                    singleLine = true,\r\n                    modifier = Modifier.weight(1f),\r\n                    colors = TextFieldDefaults.colors(\r\n                        focusedTextColor = Color.White,\r\n                        unfocusedTextColor = Color.White,\r\n                        focusedContainerColor = Color(0xFF455A64),\r\n                        unfocusedContainerColor = Color(0xFF455A64),\r\n                        focusedLabelColor = Color.White,\r\n                        unfocusedLabelColor = Color.White,\r\n                        focusedIndicatorColor = Color.White,\r\n                        unfocusedIndicatorColor = Color.White,\r\n                        cursorColor = Color.White\r\n                    )\r\n                )\r\n\r\n                Button(\r\n                    onClick = {\r\n                        discoverService(context) {\r\n                            ipAddress = it\r\n                            saveIp(it)\r\n                            Toast.makeText(context, \"üîÑ IP updated to $it\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    },\r\n                    modifier = Modifier\r\n                        .height(56.dp)\r\n                        .width(56.dp),\r\n                    shape = RoundedCornerShape(8.dp),\r\n                    colors = ButtonDefaults.buttonColors(\r\n                        containerColor = buttonColor,\r\n                        contentColor = buttonTextColor\r\n                    ),\r\n                    contentPadding = PaddingValues(0.dp)\r\n                ) {\r\n                    Text(\"üîÑ\", fontSize = 22.sp)\r\n                }\r\n            }\r\n\r\n            Spacer(modifier = Modifier.height(8.dp))\r\n\r\n            TextField(\r\n                value = password,\r\n                onValueChange = {\r\n                    password = it\r\n                    savePassword(it)\r\n                },\r\n                label = { Text(\"Server Password\", color = Color.White) },\r\n                singleLine = true,\r\n                modifier = Modifier.fillMaxWidth(),\r\n                visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),\r\n                trailingIcon = {\r\n                    IconButton(onClick = { passwordVisible = !passwordVisible }) {\r\n                        Icon(\r\n                            imageVector = if (passwordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility,\r\n                            contentDescription = if (passwordVisible) \"Hide password\" else \"Show password\",\r\n                            tint = Color.White\r\n                        )\r\n                    }\r\n                },\r\n                colors = TextFieldDefaults.colors(\r\n                    focusedTextColor = Color.White,\r\n                    unfocusedTextColor = Color.White,\r\n                    focusedContainerColor = Color(0xFF455A64),\r\n                    unfocusedContainerColor = Color(0xFF455A64),\r\n                    focusedLabelColor = Color.White,\r\n                    unfocusedLabelColor = Color.White,\r\n                    focusedIndicatorColor = Color.White,\r\n                    unfocusedIndicatorColor = Color.White,\r\n                    cursorColor = Color.White\r\n                )\r\n            )\r\n        }\r\n    }\r\n        Divider(color = Color.Gray)\r\n\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(12.dp)\r\n        ) {\r\n            Button(\r\n                onClick = {\r\n                    clipboardManager.primaryClip?.getItemAt(0)?.text?.toString()?.let { text ->\r\n                        lastText = text\r\n                        addToHistory(text)\r\n                        sendToServer(context, text, ipAddress, password)\r\n                    }\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"\\uD83D\\uDCE4 Sync Text\")\r\n            }\r\n\r\n            Button(\r\n                onClick = {\r\n                    fetchClipboardFromServer(\r\n                        context = context,\r\n                        ip = ip,\r\n                        password = password,\r\n                        clipboardManager = clipboardManager,\r\n                        addToHistory = { text -> addToHistory(text) },\r\n                        onComplete = { /* handle UI update after fetch */ }\r\n                    )\r\n\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"\\uD83D\\uDCE5 Fetch Text\")\r\n            }\r\n        }\r\n\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.spacedBy(8.dp)\r\n        ) {\r\n            Button(\r\n                onClick = { fileLauncher.launch(\"*/*\") },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"üìÅ Send File\")\r\n            }\r\n\r\n            Button(\r\n                onClick = {\r\n                    downloadingCount += 1\r\n                    fetchClipboardFromServer(\r\n                        context = context,\r\n                        ip = ipAddress,\r\n                        password = password,\r\n                        clipboardManager = clipboardManager,\r\n                        addToHistory = { text -> clipboardHistory = clipboardHistory + text },\r\n                        onComplete = { downloadingCount = maxOf(downloadingCount - 1, 0) }\r\n                    )\r\n                },\r\n                modifier = Modifier.weight(1f),\r\n                shape = RoundedCornerShape(6.dp),\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = buttonColor,\r\n                    contentColor = buttonTextColor\r\n                )\r\n            ) {\r\n                Text(\"üìÉ Fetch File\")\r\n            }\r\n\r\n\r\n        }\r\n        if (showFileDialog) {\r\n            AlertDialog(\r\n                onDismissRequest = { showFileDialog = false },\r\n                title = { Text(\"Available Files\", color = Color.White) },\r\n                text = {\r\n                    Column(\r\n                        modifier = Modifier\r\n                            .heightIn(min = 100.dp, max = 400.dp)\r\n                            .verticalScroll(rememberScrollState())\r\n                    ) {\r\n                        if (availableFiles.isEmpty()) {\r\n                            Text(\"No files found\", color = Color.White)\r\n                        } else {\r\n                            availableFiles.forEach { file ->\r\n                                Row(\r\n                                    modifier = Modifier\r\n                                        .fillMaxWidth()\r\n                                        .clickable {\r\n                                            downloadingCount += 1\r\n                                            downloadFileFromServer(context, file, ipAddress, password) {\r\n                                                downloadingCount = maxOf(downloadingCount - 1, 0)\r\n                                            }\r\n                                            showFileDialog = false\r\n                                        }\r\n                                        .padding(vertical = 8.dp),\r\n                                    verticalAlignment = Alignment.CenterVertically\r\n                                ) {\r\n                                    Text(file, color = Color.White, modifier = Modifier.weight(1f))\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                confirmButton = {\r\n                    TextButton(onClick = { showFileDialog = false }) {\r\n                        Text(\"Close\", color = Color.White)\r\n                    }\r\n                },\r\n                containerColor = Color(0xFF37474F)\r\n            )\r\n        }\r\n\r\n        if (isUploading) {\r\n            Spacer(modifier = Modifier.height(8.dp))\r\n            Text(\"Uploading...\", fontSize = 14.sp, color = Color.White)\r\n        }\r\n        if (isDownloading) {\r\n            Spacer(modifier = Modifier.height(4.dp))\r\n            Text(\"Downloading...\", fontSize = 14.sp, color = Color.White)\r\n        }\r\n\r\n        Divider(color = Color.Gray)\r\n        Text(\"Clipboard History\", fontSize = 18.sp, color = Color.White)\r\n\r\n        LazyColumn(\r\n            modifier = Modifier\r\n                .fillMaxSize()\r\n                .padding(top = 2.dp)\r\n        ) {\r\n\r\n            items(history) { item ->\r\n                Row(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .padding(vertical = 6.dp)\r\n                        .clickable { selectedItem = item },\r\n                    horizontalArrangement = Arrangement.SpaceBetween,\r\n                    verticalAlignment = Alignment.CenterVertically\r\n                ) {\r\n                    Text(\r\n                        item.take(50).replace(\"\\n\", \" \"),\r\n                        fontSize = 14.sp,\r\n                        color = Color.White,\r\n                        modifier = Modifier.weight(1f)\r\n                    )\r\n                    Row {\r\n                        IconButton(onClick = {\r\n                            val clip = ClipData.newPlainText(\"Copied\", item)\r\n                            clipboardManager.setPrimaryClip(clip)\r\n                            Toast.makeText(context, \"üìã Copied to clipboard\", Toast.LENGTH_SHORT)\r\n                                .show()\r\n                        }) {\r\n                            Text(\"üìã\", color = Color.White)\r\n                        }\r\n                        IconButton(onClick = { deleteFromHistory(item) }) {\r\n                            Text(\"üóëÔ∏è\", color = Color.White)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n        // Expanded History View Dialog\r\n    selectedItem?.let {\r\n        val scrollState = rememberScrollState()\r\n        AlertDialog(\r\n            onDismissRequest = { selectedItem = null },\r\n            title = { Text(\"Clipboard Entry\", color = Color.White) },\r\n            text = {\r\n                Column(\r\n                    modifier = Modifier\r\n                        .heightIn(min = 100.dp, max = 400.dp)\r\n                        .verticalScroll(scrollState)\r\n                        .padding(4.dp)\r\n                ) {\r\n                    Text(it, fontSize = 14.sp, color = Color.White)\r\n                }\r\n            },\r\n            confirmButton = {\r\n                TextButton(onClick = { selectedItem = null }) {\r\n                    Text(\"Close\", color = Color.White)\r\n                }\r\n            },\r\n            containerColor = Color(0xFF37474F)\r\n        )\r\n    }\r\n}\r\n// --- CONFIG --- //\r\nprivate const val PBKDF2_ITERATIONS = 10000\r\nprivate const val KEY_LENGTH = 256 // bits\r\nprivate const val SALT_SIZE = 16   // bytes\r\nprivate const val IV_SIZE = 16     // bytes\r\n\r\n// --- KEY DERIVATION --- //\r\nprivate fun deriveKey(password: String, salt: ByteArray): SecretKeySpec {\r\n    val factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\")\r\n    val spec = PBEKeySpec(password.toCharArray(), salt, PBKDF2_ITERATIONS, KEY_LENGTH)\r\n    val tmp = factory.generateSecret(spec)\r\n    return SecretKeySpec(tmp.encoded, \"AES\")\r\n}\r\n\r\n// --- RANDOM GENERATORS --- //\r\nprivate fun randomBytes(size: Int): ByteArray {\r\n    val bytes = ByteArray(size)\r\n    SecureRandom().nextBytes(bytes)\r\n    return bytes\r\n}\r\n\r\n// --- SECURE ENCRYPTION FOR TEXT --- //\r\nfun encryptAESCBC(text: String, password: String): String {\r\n    val salt = randomBytes(SALT_SIZE)\r\n    val iv = randomBytes(IV_SIZE)\r\n    val key = deriveKey(password, salt)\r\n\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\r\n    val encrypted = cipher.doFinal(text.toByteArray(Charsets.UTF_8))\r\n    // Output: salt + iv + ciphertext (all base64 encoded)\r\n    val out = ByteArray(salt.size + iv.size + encrypted.size)\r\n    System.arraycopy(salt, 0, out, 0, salt.size)\r\n    System.arraycopy(iv, 0, out, salt.size, iv.size)\r\n    System.arraycopy(encrypted, 0, out, salt.size + iv.size, encrypted.size)\r\n    return Base64.encodeToString(out, Base64.NO_WRAP)\r\n}\r\n\r\nfun decryptAESCBC(encrypted: String, password: String): String {\r\n    val decoded = Base64.decode(encrypted, Base64.NO_WRAP)\r\n    val salt = decoded.copyOfRange(0, SALT_SIZE)\r\n    val iv = decoded.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n    val ciphertext = decoded.copyOfRange(SALT_SIZE + IV_SIZE, decoded.size)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n    val decrypted = cipher.doFinal(ciphertext)\r\n    return String(decrypted, Charsets.UTF_8)\r\n}\r\n\r\n// --- SECURE ENCRYPTION FOR FILES (BYTES) --- //\r\nfun encryptFileBytesCBC(data: ByteArray, password: String): ByteArray {\r\n    val salt = randomBytes(SALT_SIZE)\r\n    val iv = randomBytes(IV_SIZE)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\r\n    val encrypted = cipher.doFinal(data)\r\n    // Output: salt + iv + ciphertext\r\n    val out = ByteArray(salt.size + iv.size + encrypted.size)\r\n    System.arraycopy(salt, 0, out, 0, salt.size)\r\n    System.arraycopy(iv, 0, out, salt.size, iv.size)\r\n    System.arraycopy(encrypted, 0, out, salt.size + iv.size, encrypted.size)\r\n    return out\r\n}\r\n\r\nfun decryptFileBytesCBC(data: ByteArray, password: String): ByteArray {\r\n    val salt = data.copyOfRange(0, SALT_SIZE)\r\n    val iv = data.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n    val ciphertext = data.copyOfRange(SALT_SIZE + IV_SIZE, data.size)\r\n    val key = deriveKey(password, salt)\r\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n    cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n    return cipher.doFinal(ciphertext)\r\n}\r\n\r\nfun showDownloadNotification(context: Context, filePathOrUri: String, filename: String, mimeType: String) {\r\n    val channelId = \"clipboard_download_channel\"\r\n    val notificationId = 1001\r\n\r\n    // Channel creation should NOT depend on permission!\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        val name = \"ClipboardSync Downloads\"\r\n        val descriptionText = \"Notifications for completed file downloads\"\r\n        val importance = NotificationManager.IMPORTANCE_DEFAULT\r\n        val channel = NotificationChannel(channelId, name, importance).apply {\r\n            description = descriptionText\r\n        }\r\n        val notificationManager: NotificationManager =\r\n            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n        notificationManager.createNotificationChannel(channel)\r\n    }\r\n\r\n    // Check notification permission for Android 13+ (API 33+)\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU &&\r\n        ActivityCompat.checkSelfPermission(context, android.Manifest.permission.POST_NOTIFICATIONS)\r\n        != PackageManager.PERMISSION_GRANTED) {\r\n        // Permission not granted, just return (don't crash)\r\n        return\r\n    }\r\n\r\n    // Prepare an intent to open the file\r\n    val fileUri: Uri = if (filePathOrUri.startsWith(\"content://\")) {\r\n        Uri.parse(filePathOrUri)\r\n    } else {\r\n        File(filePathOrUri).let { file ->\r\n            FileProvider.getUriForFile(context, context.packageName + \".provider\", file)\r\n        }\r\n    }\r\n\r\n    val openIntent = Intent(Intent.ACTION_VIEW).apply {\r\n        setDataAndType(fileUri, mimeType)\r\n        addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK)\r\n    }\r\n    val pendingIntent = PendingIntent.getActivity(\r\n        context, 0, openIntent,\r\n        PendingIntent.FLAG_UPDATE_CURRENT or\r\n                (if (Build.VERSION.SDK_INT >= 31) PendingIntent.FLAG_MUTABLE else 0)\r\n    )\r\n\r\n    val notification = NotificationCompat.Builder(context, channelId)\r\n        .setSmallIcon(android.R.drawable.stat_sys_download_done)\r\n        .setContentTitle(\"Download complete\")\r\n        .setContentText(filename)\r\n        .setPriority(NotificationCompat.PRIORITY_DEFAULT)\r\n        .setAutoCancel(true)\r\n        .addAction(android.R.drawable.ic_menu_view, \"Open\", pendingIntent)\r\n        .build()\r\n\r\n    NotificationManagerCompat.from(context).notify(notificationId, notification)\r\n}\r\n\r\nfun pingServer(context: Context, ip: String, password: String, onResult: (Boolean) -> Unit) {\r\n    if (ip.isBlank()) {\r\n        onResult(false)\r\n        return\r\n    }\r\n\r\n    CoroutineScope(Dispatchers.IO).launch {\r\n        try {\r\n            val client = OkHttpClient.Builder()\r\n                .callTimeout(2, TimeUnit.SECONDS)\r\n                .build()\r\n\r\n            val request = Request.Builder()\r\n                .url(\"http://$ip:8000/ping\")\r\n                .get()\r\n                .addHeader(\"X-Auth-Token\", password)\r\n                .build()\r\n\r\n            val response = client.newCall(request).execute()\r\n            onResult(response.isSuccessful)\r\n        } catch (e: Exception) {\r\n            onResult(false)\r\n        }\r\n    }\r\n}\r\n\r\nfun loadHistory(prefs: SharedPreferences): List<String> {\r\n    val json = prefs.getString(\"clipboard_history\", \"[]\")\r\n    return try {\r\n        val arr = JSONArray(json)\r\n        List(arr.length()) { i -> arr.getString(i) }\r\n    } catch (e: Exception) {\r\n        emptyList()\r\n    }\r\n}\r\n\r\nfun discoverService(context: Context, onFound: (String) -> Unit) {\r\n    val nsdManager = context.getSystemService(Context.NSD_SERVICE) as NsdManager\r\n    val serviceType = \"_http._tcp.\"\r\n    val serviceNamePrefix = \"ClipboardSyncServer\"\r\n    lateinit var discoveryListener: NsdManager.DiscoveryListener\r\n\r\n    discoveryListener = object : NsdManager.DiscoveryListener {\r\n        override fun onDiscoveryStarted(serviceType: String) {}\r\n        override fun onStopDiscoveryFailed(serviceType: String?, errorCode: Int) {}\r\n        override fun onStartDiscoveryFailed(serviceType: String?, errorCode: Int) {}\r\n        override fun onDiscoveryStopped(serviceType: String) {}\r\n        override fun onServiceFound(serviceInfo: NsdServiceInfo) {\r\n            if (serviceInfo.serviceName.contains(serviceNamePrefix)) {\r\n                nsdManager.resolveService(serviceInfo, object : NsdManager.ResolveListener {\r\n                    override fun onResolveFailed(serviceInfo: NsdServiceInfo?, errorCode: Int) {}\r\n                    override fun onServiceResolved(resolved: NsdServiceInfo) {\r\n                        val host = resolved.host.hostAddress\r\n                        if (host != null) {\r\n                            onFound(host)\r\n                            nsdManager.stopServiceDiscovery(discoveryListener)\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        override fun onServiceLost(serviceInfo: NsdServiceInfo) {}\r\n    }\r\n\r\n    nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryListener)\r\n}\r\n\r\nfun uploadFileToServer(context: Context,\r\n                       uri: Uri,\r\n                       ip: String,\r\n                       password: String,\r\n                       onUploadingChanged: (Boolean) -> Unit) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        return\r\n    }\r\n    onUploadingChanged(true)\r\n    val contentResolver = context.contentResolver\r\n\r\n    // Step 1: Get MIME type and map to extension\r\n    val mimeType = contentResolver.getType(uri)\r\n    val extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType) ?: \"bin\"\r\n\r\n    // Step 2: Try to get the original filename or fallback\r\n    var fileName = uri.lastPathSegment?.substringAfterLast('/') ?: \"upload\"\r\n\r\n    // Step 3: Ensure filename has correct extension\r\n    if (!fileName.contains('.')) {\r\n        fileName += \".$extension\"\r\n    }\r\n\r\n    val inputStream = contentResolver.openInputStream(uri) ?: return\r\n    val tempFile = File.createTempFile(\"upload\", null, context.cacheDir)\r\n    inputStream.use { input -> tempFile.outputStream().use { output -> input.copyTo(output) } }\r\n\r\n    val fileBytes = tempFile.readBytes()\r\n    val encryptedBytes = encryptFileBytesCBC(fileBytes, password)\r\n    tempFile.writeBytes(encryptedBytes)\r\n\r\n    val fileBody = tempFile.asRequestBody(\"application/octet-stream\".toMediaTypeOrNull())\r\n\r\n    val multipartBody = MultipartBody.Builder()\r\n        .setType(MultipartBody.FORM)\r\n        .addFormDataPart(\"file\", fileName, fileBody)\r\n        .build()\r\n\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/upload\")\r\n        .post(multipartBody)\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    val client = OkHttpClient()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Upload failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onUploadingChanged(false) // Upload ended with failure\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                if (response.isSuccessful) {\r\n                    Toast.makeText(context, \"‚úÖ File uploaded successfully\", Toast.LENGTH_SHORT).show()\r\n                } else {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Upload failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n                onUploadingChanged(false) // Upload ended (success or failure)\r\n            }\r\n        }\r\n    })\r\n}\r\nfun fetchFileListFromServer(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    onResult: (List<String>) -> Unit\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onResult(emptyList())\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/list-files\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Failed to get file list\", Toast.LENGTH_SHORT).show()\r\n                onResult(emptyList())\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onResult(emptyList())\r\n                }\r\n                return\r\n            }\r\n\r\n            val body = response.body?.string()\r\n            val fileList = try {\r\n                val json = JSONObject(body ?: \"{}\")\r\n                val filesArray = json.getJSONArray(\"files\")\r\n                List(filesArray.length()) { i -> filesArray.getString(i) }\r\n            } catch (e: Exception) {\r\n                emptyList()\r\n            }\r\n\r\n            Handler(Looper.getMainLooper()).post {\r\n                onResult(fileList)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun saveFileToDownloads(\r\n    context: Context,\r\n    filename: String,\r\n    mimeType: String,\r\n    inputStream: InputStream,\r\n    size: Long\r\n): String? {\r\n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n        // API 29+\r\n        val values = ContentValues().apply {\r\n            put(MediaStore.Downloads.DISPLAY_NAME, filename)\r\n            put(MediaStore.Downloads.MIME_TYPE, mimeType)\r\n            put(MediaStore.Downloads.IS_PENDING, 1)\r\n        }\r\n\r\n        val resolver = context.contentResolver\r\n        val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n        val fileUri = resolver.insert(collection, values)\r\n\r\n        if (fileUri != null) {\r\n            resolver.openOutputStream(fileUri)?.use { output ->\r\n                inputStream.copyTo(output)\r\n            }\r\n            values.clear()\r\n            values.put(MediaStore.Downloads.IS_PENDING, 0)\r\n            resolver.update(fileUri, values, null, null)\r\n            return fileUri.toString()\r\n        } else {\r\n            null\r\n        }\r\n    } else {\r\n        // Below API 29\r\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n        if (!downloadsDir.exists()) downloadsDir.mkdirs()\r\n        val file = File(downloadsDir, filename)\r\n        inputStream.use { input ->\r\n            file.outputStream().use { output ->\r\n                input.copyTo(output)\r\n            }\r\n        }\r\n        return file.absolutePath\r\n    }\r\n}\r\n\r\nfun downloadFileFromServer(\r\n    context: Context,\r\n    filename: String,\r\n    ip: String,\r\n    password: String,\r\n    onComplete: () -> Unit = {}\r\n) {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onComplete()\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download/$filename\")\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful || response.body == null) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onComplete()\r\n                }\r\n                return\r\n            }\r\n            try {\r\n                val encryptedStream = response.body!!.byteStream()\r\n                // --- Patch: decode base64 on the fly ---\r\n                val b64Stream = Base64InputStream(encryptedStream, android.util.Base64.DEFAULT)\r\n\r\n                // Read salt + iv headers (first 32 bytes) from the decoded stream\r\n                val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n                var read = 0\r\n                while (read < header.size) {\r\n                    val r = b64Stream.read(header, read, header.size - read)\r\n                    if (r == -1) throw IOException(\"Unexpected EOF in header\")\r\n                    read += r\r\n                }\r\n                val salt = header.copyOfRange(0, SALT_SIZE)\r\n                val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n                val key = deriveKey(password, salt)\r\n                val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n                cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n                val decryptedStream = CipherInputStream(b64Stream, cipher)\r\n\r\n                val mimeType = URLConnection.guessContentTypeFromName(filename)\r\n                    ?: \"application/octet-stream\"\r\n\r\n                val savedPath = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    saveToDownloadsQAndAbove(context, filename, mimeType, decryptedStream, -1)\r\n                } else {\r\n                    saveToDownloadsLegacy(context, filename, decryptedStream)\r\n                }\r\n\r\n                Handler(Looper.getMainLooper()).post {\r\n                    if (savedPath != null) {\r\n                        Toast.makeText(context, \"‚úÖ Downloaded to: $savedPath\", Toast.LENGTH_LONG).show()\r\n                        showDownloadNotification(context, savedPath, filename, mimeType)\r\n                    } else {\r\n                        Toast.makeText(context, \"‚ùå Failed to save file\", Toast.LENGTH_LONG).show()\r\n                    }\r\n                    onComplete()\r\n                }\r\n            } catch (e: Exception) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"‚ùå File decryption failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                    onComplete()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nprivate fun deleteAllDownloadsByNameBlocking(context: Context, fileName: String, timeoutMs: Long = 2000) {\r\n    // Only call this for API 29+\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) return\r\n\r\n    val resolver = context.contentResolver\r\n    val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n    val startTime = System.currentTimeMillis()\r\n    while (true) {\r\n        var found = false\r\n        val cursor = resolver.query(\r\n            collection,\r\n            arrayOf(MediaStore.Downloads._ID, MediaStore.Downloads.DISPLAY_NAME),\r\n            \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n            arrayOf(fileName),\r\n            null\r\n        )\r\n        cursor?.use {\r\n            val idCol = cursor.getColumnIndexOrThrow(MediaStore.Downloads._ID)\r\n            while (cursor.moveToNext()) {\r\n                found = true\r\n                val id = cursor.getLong(idCol)\r\n                val uri = ContentUris.withAppendedId(collection, id)\r\n                resolver.delete(uri, null, null)\r\n            }\r\n        }\r\n        if (!found) break\r\n        if (System.currentTimeMillis() - startTime > timeoutMs) break\r\n        Thread.sleep(100)\r\n    }\r\n}\r\n\r\nprivate fun saveToDownloadsQAndAbove(\r\n    context: Context,\r\n    filename: String,\r\n    mimeType: String,\r\n    inputStream: InputStream,\r\n    size: Long\r\n): String? {\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) return null\r\n    val resolver = context.contentResolver\r\n    val collection = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n    try {\r\n        // Robust delete before insert, blocking until gone or timeout\r\n        deleteAllDownloadsByNameBlocking(context, filename)\r\n        val values = ContentValues().apply {\r\n            put(MediaStore.Downloads.DISPLAY_NAME, filename)\r\n            put(MediaStore.Downloads.MIME_TYPE, mimeType)\r\n            put(MediaStore.Downloads.IS_PENDING, 1)\r\n            if (size > 0) put(MediaStore.Downloads.SIZE, size)\r\n        }\r\n        val fileUri = resolver.insert(collection, values)\r\n        if (fileUri != null) {\r\n            resolver.openOutputStream(fileUri)?.use { output ->\r\n                val buffer = ByteArray(8192)\r\n                var len: Int\r\n                while (inputStream.read(buffer).also { len = it } != -1) {\r\n                    output.write(buffer, 0, len)\r\n                }\r\n            }\r\n            values.clear()\r\n            values.put(MediaStore.Downloads.IS_PENDING, 0)\r\n            resolver.update(fileUri, values, null, null)\r\n            return fileUri.toString()\r\n        } else {\r\n            // Last resort: MediaStore may still have a ghost file; check if file now exists\r\n            val cursor = resolver.query(\r\n                collection,\r\n                arrayOf(MediaStore.Downloads._ID),\r\n                \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n                arrayOf(filename),\r\n                null\r\n            )\r\n            val exists = cursor?.moveToFirst() == true\r\n            cursor?.close()\r\n            return if (exists) \"mediastore://found/$filename\" else null\r\n        }\r\n    } catch (e: Exception) {\r\n        e.printStackTrace()\r\n        // Last resort: MediaStore error, but maybe file is present\r\n        val cursor = resolver.query(\r\n            collection,\r\n            arrayOf(MediaStore.Downloads._ID),\r\n            \"${MediaStore.Downloads.DISPLAY_NAME}=?\",\r\n            arrayOf(filename),\r\n            null\r\n        )\r\n        val exists = cursor?.moveToFirst() == true\r\n        cursor?.close()\r\n        return if (exists) \"mediastore://found/$filename\" else null\r\n    }\r\n}\r\n\r\n\r\nprivate fun saveToDownloadsLegacy(\r\n    context: Context,\r\n    filename: String,\r\n    inputStream: InputStream\r\n): String? {\r\n    val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\r\n    if (!downloadsDir.exists()) downloadsDir.mkdirs()\r\n    val outFile = File(downloadsDir, filename)\r\n    if (outFile.exists()) outFile.delete()\r\n    return try {\r\n        inputStream.use { input ->\r\n            outFile.outputStream().use { output ->\r\n                val buffer = ByteArray(8192)\r\n                var len: Int\r\n                while (input.read(buffer).also { len = it } != -1) {\r\n                    output.write(buffer, 0, len)\r\n                }\r\n            }\r\n        }\r\n        outFile.absolutePath\r\n    } catch (e: Exception) {\r\n        e.printStackTrace()\r\n        null\r\n    }\r\n}\r\n\r\nfun sendToServer(context: Context, text: String, ip: String, password: String, onStatusChange: (Boolean) -> Unit = {})\r\n {\r\n    if (ip.isBlank()) {\r\n        Toast.makeText(context, \"‚ùó No IP address configured\", Toast.LENGTH_SHORT).show()\r\n        onStatusChange(false)\r\n        return\r\n    }\r\n\r\n    val client = OkHttpClient()\r\n     val encryptedText = encryptAESCBC(text, password)\r\n     val requestBody = FormBody.Builder().add(\"clipboard\", encryptedText).build()\r\n\r\n     val request = Request.Builder()\r\n        .url(\"http://$ip:8000/clipboard\")\r\n        .post(requestBody)\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                onStatusChange(false) // Notify failure\r\n                Toast.makeText(context, \"‚ùå Failed to sync: ${e.localizedMessage}\", Toast.LENGTH_LONG).show()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                val isSuccess = response.isSuccessful\r\n                onStatusChange(isSuccess)  // Pass status as Boolean\r\n\r\n                if (isSuccess) {\r\n                    Toast.makeText(context, \"‚úÖ Clipboard synced\", Toast.LENGTH_SHORT).show()\r\n                } else {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun fetchClipboardFromServer(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    clipboardManager: ClipboardManager,\r\n    addToHistory: (String) -> Unit,\r\n    onComplete: () -> Unit\r\n) {\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/clipboard\")\r\n        .get()\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n\r\n    val client = OkHttpClient()\r\n\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Fetch failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n\r\n        override fun onResponse(call: Call, response: Response) {\r\n            response.use {\r\n                if (!it.isSuccessful) {\r\n                    Handler(Looper.getMainLooper()).post {\r\n                        Toast.makeText(context, \"‚ö†Ô∏è Server error: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                        onComplete()\r\n                    }\r\n                    return\r\n                }\r\n\r\n                val bodyString = it.body?.string()\r\n                val json = JSONObject(bodyString)\r\n                val isFile = json.optBoolean(\"is_file\", false)\r\n\r\n                if (isFile) {\r\n                    val filename = json.optString(\"filename\", \"fetched_file\")\r\n                    downloadFileFromClipboard(context, ip, password, filename, onComplete)\r\n                } else {\r\n                    val encryptedText = json.getString(\"clipboard\")\r\n                    val text = decryptAESCBC(encryptedText, password)\r\n                    Handler(Looper.getMainLooper()).post {\r\n                        clipboardManager.setPrimaryClip(ClipData.newPlainText(\"label\", text))\r\n                        addToHistory(text)\r\n                        Toast.makeText(context, \"üìã Clipboard updated\", Toast.LENGTH_SHORT).show()\r\n                        onComplete()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\nfun downloadFileFromClipboard(\r\n    context: Context,\r\n    ip: String,\r\n    password: String,\r\n    filename: String,\r\n    onComplete: () -> Unit\r\n) {\r\n    val request = Request.Builder()\r\n        .url(\"http://$ip:8000/download_clipboard_file\")\r\n        .get()\r\n        .addHeader(\"X-Auth-Token\", password)\r\n        .build()\r\n    val client = OkHttpClient()\r\n    client.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            Handler(Looper.getMainLooper()).post {\r\n                Toast.makeText(context, \"‚ùå Download failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                onComplete()\r\n            }\r\n        }\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (!response.isSuccessful || response.body == null) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"‚ö†Ô∏è Download failed: ${response.code}\", Toast.LENGTH_SHORT).show()\r\n                    onComplete()\r\n                }\r\n                return\r\n            }\r\n            try {\r\n                val encryptedStream = response.body!!.byteStream()\r\n                // --- Patch: decode base64 on the fly ---\r\n                val b64Stream = Base64InputStream(encryptedStream, android.util.Base64.DEFAULT)\r\n\r\n                // Read salt + iv headers (first 32 bytes) from the decoded stream\r\n                val header = ByteArray(SALT_SIZE + IV_SIZE)\r\n                var read = 0\r\n                while (read < header.size) {\r\n                    val r = b64Stream.read(header, read, header.size - read)\r\n                    if (r == -1) throw IOException(\"Unexpected EOF in header\")\r\n                    read += r\r\n                }\r\n                val salt = header.copyOfRange(0, SALT_SIZE)\r\n                val iv = header.copyOfRange(SALT_SIZE, SALT_SIZE + IV_SIZE)\r\n                val key = deriveKey(password, salt)\r\n                val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n                cipher.init(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv))\r\n                val decryptedStream = CipherInputStream(b64Stream, cipher)\r\n\r\n                val mimeType = URLConnection.guessContentTypeFromName(filename) ?: \"application/octet-stream\"\r\n                val savedPath: String? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    saveToDownloadsQAndAbove(context, filename, mimeType, decryptedStream, -1)\r\n                } else {\r\n                    saveToDownloadsLegacy(context, filename, decryptedStream)\r\n                }\r\n                Handler(Looper.getMainLooper()).post {\r\n                    if (savedPath != null) {\r\n                        Toast.makeText(context, \"‚úÖ File downloaded: $filename\", Toast.LENGTH_SHORT).show()\r\n                    } else {\r\n                        Toast.makeText(context, \"‚ùå Failed to save file\", Toast.LENGTH_LONG).show()\r\n                    }\r\n                    onComplete()\r\n                }\r\n            } catch (e: Exception) {\r\n                Handler(Looper.getMainLooper()).post {\r\n                    Toast.makeText(context, \"‚ùå File decryption failed: ${e.message}\", Toast.LENGTH_LONG).show()\r\n                    onComplete()\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        // Request notification permission for Android 13+ (API 33+)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\r\n            if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS)\r\n                != PackageManager.PERMISSION_GRANTED\r\n            ) {\r\n                requestPermissions(arrayOf(android.Manifest.permission.POST_NOTIFICATIONS), 123)\r\n            }\r\n        }\r\n        setContent { ClipboardSyncApp() }\r\n        checkOverlayPermission()\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n\r\n        val prefs = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n\r\n        if (intent.getBooleanExtra(\"syncNow\", false)) {\r\n            Handler(Looper.getMainLooper()).postDelayed({\r\n                syncClipboardFromActivity()\r\n                intent.removeExtra(\"syncNow\")\r\n            }, 50)\r\n        }\r\n\r\n        if (intent.getBooleanExtra(\"fetchNow\", false)) {\r\n            Handler(Looper.getMainLooper()).postDelayed({\r\n                val clipboardManager = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n                val password = prefs.getString(\"password\", \"\") ?: \"\"\r\n\r\n                fetchClipboardFromServer(\r\n                    context = this,\r\n                    ip = prefs.getString(\"server_ip\", \"\") ?: \"\",\r\n                    password = password,\r\n                    clipboardManager = clipboardManager,\r\n                    addToHistory = { _ -> }, // assuming you have this function\r\n                    onComplete = {\r\n                        Handler(Looper.getMainLooper()).postDelayed({\r\n                            moveTaskToBack(true)\r\n                        }, 1000)\r\n                    }\r\n                )\r\n                intent.removeExtra(\"fetchNow\")\r\n                Handler(Looper.getMainLooper()).postDelayed({\r\n                    moveTaskToBack(true)\r\n                }, 1000) // ‚úÖ same delay as sync\r\n            }, 50)\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private fun syncClipboardFromActivity() {\r\n        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\r\n        val clip = clipboard.primaryClip\r\n        val text = clip?.getItemAt(0)?.text?.toString()\r\n        val prefs = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\r\n        val ip = prefs.getString(\"server_ip\", \"\") ?: \"\"\r\n\r\n        if (!text.isNullOrEmpty()) {\r\n            val password = prefs.getString(\"server_password\", \"\") ?: \"\"\r\n            sendToServer(this, text, ip, password)\r\n        } else {\r\n            Toast.makeText(this, \"\\uD83D\\uDCCB Clipboard is empty\", Toast.LENGTH_SHORT).show()\r\n        }\r\n\r\n        Handler(Looper.getMainLooper()).postDelayed({\r\n            moveTaskToBack(true)\r\n        }, 1000)\r\n    }\r\n\r\n    private fun checkOverlayPermission() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            if (!Settings.canDrawOverlays(this)) {\r\n                val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:$packageName\"))\r\n                startActivity(intent)\r\n            } else {\r\n                startOverlayService()\r\n            }\r\n        } else {\r\n            startOverlayService()\r\n        }\r\n    }\r\n\r\n    private fun startOverlayService() {\r\n        val intent = Intent(this, OverlayService::class.java)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(intent)\r\n        else startService(intent)\r\n\r\n        Toast.makeText(this, \"\\u2705 Overlay service started\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n",
  "def derive_key(password: str, salt: bytes) -> bytes:\r\n    \"\"\"Derive a key from password and salt using PBKDF2 (HMAC-SHA256).\"\"\"\r\n    return PBKDF2(password, salt, dkLen=KEY_LEN, count=PBKDF2_ITER, hmac_hash_module=SHA256)"
]